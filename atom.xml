<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>他乡之客</title>
  
  <subtitle>Excellence is an art won by training and habituation.</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-26T07:02:51.688Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Joseph Smith</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中英文写作习惯</title>
    <link href="http://example.com/2022/10/26/%E4%B8%AD%E8%8B%B1%E6%96%87%E5%86%99%E4%BD%9C%E4%B9%A0%E6%83%AF/"/>
    <id>http://example.com/2022/10/26/%E4%B8%AD%E8%8B%B1%E6%96%87%E5%86%99%E4%BD%9C%E4%B9%A0%E6%83%AF/</id>
    <published>2022-10-26T03:04:47.000Z</published>
    <updated>2022-10-26T07:02:51.688Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <span id="more"></span><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{% pdf https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>Josephucas<span class="regexp">/Josephucas.github.io/</span>tree<span class="regexp">/hexo/</span>pdf/中式英文书写错误习惯勘误.pdf %}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>相关癌症简介</title>
    <link href="http://example.com/2022/10/25/%E7%9B%B8%E5%85%B3%E7%99%8C%E7%97%87%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2022/10/25/%E7%9B%B8%E5%85%B3%E7%99%8C%E7%97%87%E7%AE%80%E4%BB%8B/</id>
    <published>2022-10-25T12:13:13.000Z</published>
    <updated>2022-10-26T03:10:30.196Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <span id="more"></span><p>大肠癌</p><p><a href="https://www.uptodate.com/contents/zh-Hans/colorectal-cancer-epidemiology-risk-factors-and-protective-factors?topicRef=2507&amp;source=see_link">https://www.uptodate.com/contents/zh-Hans/colorectal-cancer-epidemiology-risk-factors-and-protective-factors?topicRef=2507&amp;source=see_link</a></p><p>胃癌</p><p>糖尿病</p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>改善肠胃饮食建议</title>
    <link href="http://example.com/2022/10/24/%E6%94%B9%E5%96%84%E8%82%A0%E8%83%83%E9%A5%AE%E9%A3%9F%E5%BB%BA%E8%AE%AE/"/>
    <id>http://example.com/2022/10/24/%E6%94%B9%E5%96%84%E8%82%A0%E8%83%83%E9%A5%AE%E9%A3%9F%E5%BB%BA%E8%AE%AE/</id>
    <published>2022-10-24T12:57:50.000Z</published>
    <updated>2022-10-26T03:10:30.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改善肠胃饮食建议"><a class="markdownIt-Anchor" href="#改善肠胃饮食建议"></a> 改善肠胃饮食建议</h1><p>[TOC]</p><span id="more"></span><p align="right">乐乐</p> <p>​针对爸爸胃部和肠部的的各种问题，我通过查阅相关书籍，整理了一些肠胃饮食建议：</p><h2 id="日常饮食推荐"><a class="markdownIt-Anchor" href="#日常饮食推荐"></a> 日常饮食推荐</h2><h3 id="肉蛋奶"><a class="markdownIt-Anchor" href="#肉蛋奶"></a> 肉蛋奶</h3><p>​一个不常运动的人正常补充的蛋白质是每公斤0.75g，以140斤来算，大概是55g-60g，两个手掌大小的肉、鱼、豆腐、坚果或豆类，一个鸡蛋补充7g蛋白质，二两猪肉或者鸡肉含有25g蛋白质，豆类虽然有蛋白质，但是不利于吸收</p><p>​完全素食是不可能的，而且会出大问题</p><p>蛋白质的摄入推荐是<strong>每天两个鸡蛋+400ml牛奶+二两-三两肉类（瘦肉，鱼虾，鸡肉）</strong></p><blockquote><p>资料来自《你是吃出来的》</p></blockquote><ul><li>肉类</li></ul><p>​肉类可以的话，尽量往白肉（鱼虾<strong>鸡</strong>鸭）方向吃，尤其是鸡肉和鱼肉。</p><p>红肉（猪肉羊肉牛肉等）也不是不可以吃，但是要少吃，限制每天二两，长期大量摄入会增加大肠癌发病率</p><blockquote><p>资料来自《曾医生让你早知道》</p></blockquote><ul><li>蛋类</li></ul><p>鸡蛋每天两个差不多</p><ul><li>奶</li></ul><p>​虽然家里买了一些奶粉，可以每天泡奶粉喝</p><p>​但是为了改善肠道的益生菌之类的，有条件可以去超市买2L的那种酸奶，两个大人吃的化，一两天就可以吃完，酸奶选择<strong>原味的发酵乳</strong>。</p><p>​乳酸菌饮料是基本没有的，假的。</p><blockquote><p>资料来自《曾医生让你早知道》</p></blockquote><h3 id="粗粮"><a class="markdownIt-Anchor" href="#粗粮"></a> 粗粮</h3><p>​需要适当吃粗粮（<strong>玉米</strong>、小米、红米、黑米、紫米、高粱、大麦、<strong>燕麦</strong>、荞麦，<strong>红薯</strong>、山药、马铃，黄豆、绿豆、红豆、黑豆、蚕豆、豌豆薯）</p><p>​早上吃<strong>燕麦</strong>不仅很方便，而且吃粗粮可以明显缓解糖尿病患者餐后高血糖状态，减少24小时内血糖波动</p><p>粗粮和细粮的比例可以是1/3，也就是早上粗粮，中午和晚上是细粮</p><p>需要注意的是，吃粗粮（杂粮）要多喝水，及时补水，不然也同样会造成便秘</p><h3 id="蔬菜"><a class="markdownIt-Anchor" href="#蔬菜"></a> 蔬菜</h3><p>多吃蔬菜，差不多一天一斤，蔬菜可以增加膳食纤维和维生素，除了绿叶蔬菜外，我还找了与肠胃相对应的一些蔬菜</p><ul><li><strong>西蓝花</strong>（西兰花）</li></ul><p>西兰花是抗癌明星，肯定是可以吃的</p><ul><li><strong>胡萝卜和芹菜</strong></li></ul><p>​胡萝卜和芹菜都是找到对结肠有较大好处的，有空可以买来吃</p><blockquote><p>资料来自《营养圣经》和百科</p></blockquote><ul><li><strong>大蒜</strong></li></ul><p>​大蒜是我找到的对胃部和肠部有好处比较多的，<strong>建议是可以每天吃最少一瓣，也可以和蔬菜当配菜吃</strong>，要是实在不行，下策只能找大蒜素的药</p><blockquote><p>资料来自《营养圣经》</p></blockquote><h3 id="水果"><a class="markdownIt-Anchor" href="#水果"></a> 水果</h3><p>​水果肯定是要吃，但是为了控制血糖，需要吃含糖量低一些，升糖指数低一些的水果，但是即使是这样，大部分水果的升糖指数还是要低于粥和馒头，也就是说吃馒头和喝粥比吃水果血糖升的还快</p><blockquote><p>资料来自《你是吃出来的》</p></blockquote><p>​血糖生成指数（ GI）通常反映了一个食物能够引起人体血糖升高多少的能力。低GI食物，在胃肠中停留时间长，吸收率低，葡萄糖释放缓慢，葡萄糖进入血液后的峰值低、下降速度也慢， 简单说就是血糖比较低。糖尿病人应该选择GI低的水果。</p><p>下表是不同水果的GI平均值，但是相同水果又因为品种、产地、成熟度等不同，对血糖的影响也不一样。<strong>糖尿病患者选择水果需要跟健康人选择水果的方式不一样，尽量选择不太甜的，成熟度低的水果。</strong></p><p>推荐：</p><ul><li>苹果</li><li>柚子</li><li>火龙果</li><li>山楂（新鲜的）</li><li>猕猴桃</li></ul><p>少吃：</p><ul><li>西瓜</li><li>荔枝</li><li>甘蔗</li><li>葡萄</li><li>哈密瓜</li><li>菠萝</li><li>果脯类如葡萄干</li></ul><p>糖尿病人可以适当的吃一些水果，只要是在合适的时间，吃升糖指数低的水果，一般就不会导致血糖升高。吃水果的时候<strong>可以选择在两餐之间或者体力劳动之后吃</strong>，比如可以在上午9点以后，下午3点左右，或者晚餐后一个小时的时候吃一些升糖很慢的水果。</p><h3 id="维生素c片"><a class="markdownIt-Anchor" href="#维生素c片"></a> 维生素C片</h3><p>​每天吃2-3片维生素</p><p>维生素C能抗氧化和提升免疫力，钱学森老年从80岁每天吃超过常人100倍（至少10粒）的维生素C，吃了十几年。正常人肯定不用每天吃维生素C，因为他们能从水果蔬菜中补充，我平常水果吃得少，所以一天一粒。</p><p>但是我觉得爸爸现在就必须开始每天补充维生素C，有以下几个原因：</p><ul><li>你现在的身体处于亚健康状态，你需要更多的<strong>抗氧化物</strong>对抗体内含有的癌细胞，所以正常的补充维生素C已经是不够的。</li><li>由于爸爸你需要<strong>控制血糖</strong>，所以不能吃太多升糖指数高（葡萄、荔枝、甘蔗）的水果，但也不能一天吃十个苹果，一个苹果的维生素C是30mg，一片维生素C是100mg，维生素C还可以不摄入水果的糖分</li><li>蔬菜中的维生素C熔点是190°-192°，正常炒菜会有些蔬菜的维生素C有一部分消耗。</li></ul><p>​所以就爸爸的身体来说，从现在开始，每天补充额外的维生素C是有必要的。查阅欧美那边的书籍，你这样的身体一天要补充的维生素C总量是1000mg，一个人最多一天不能超过2000mg维生素C,不然也会出问题。</p><p>​所以我们谨慎一点，每天除了正常吃苹果（火龙果，柚子这类升糖指数不是那么高，猕猴桃，西红柿也可以）和吃蔬菜外，每天补充300mg额外的维生素C，也就是三片。注意事项如下：</p><ul><li>维生素C不用买花里胡哨的，就是去医院或者药店买最简单的小瓶子100片的3-4块钱的维生素C片，其他的都不行；购买的时候就说自己牙龈出血，想吃一些维生素C。</li><li><strong>维生素C的服用遵守饭间服用或者饭后立即服用的原则，吃饭的时候吃或者吃完饭再吃；如果有一餐忘记服用了，那么下一餐记起来的时候就要吃两粒，但是一餐最多吃两粒</strong>，比如早上和中午都忘记吃了，那么晚餐就要吃两粒。那么一天下来，维生素C稳定在2-3粒，当你一天吃两粒的时候，说明你早上和中午都忘记吃了。</li><li>维生素C最多一天不能超过10粒，超过了虽然没什么大问题，但是最好不要超过10粒</li><li>如果三餐都能忘记吃维生素C了，那么这个时候要看一下表，如果时间在晚上9点以前，还能喝点水的情况下，可以补充一粒，但是一旦九点钟以后就不要吃了，忘记一天也没什么关系，第二天继续吃就可以了，因为维生素C时水溶性的，需要喝水，但是晚上九点钟以后就要少喝水了，所以就不能吃了</li><li>如果后续病情出现恶化，可能需要每餐两粒维生素C。</li></ul><h3 id="坚果"><a class="markdownIt-Anchor" href="#坚果"></a> 坚果</h3><p>​坚果的好处不用提了（把它当成植物鱼油一样），反正<strong>要当成维生素C一样每天吃</strong>，但是一定要防止发霉（<strong>黄曲霉素</strong>），所以葵花子这些基本就不要吃了。</p><p>​我建议是直接买<strong>真空包装的全熟的原味巴旦木</strong>，一天吃10个，也不多也不少，差不多10g。</p><p>买其他的都不好计量，就这个最好数，一劳永逸！其他坚果都不用吃了，不好算数。有糖衣的核桃和带壳有糖的巴旦木，尽量少吃，这对血糖不好把控；带盐味的也不吃，不好控制血压。</p><blockquote><p>坚果每天吃多少克的资料来自《中国居民膳食指南》</p></blockquote><h3 id="运动"><a class="markdownIt-Anchor" href="#运动"></a> 运动</h3><p>​最基本的可以每天跑跑步，散散步，但是怕坚持不下来。如果有条件，可以养一条狗，每天强制让它带着爸爸出去遛弯一个小时。</p><h3 id="晒晒太阳"><a class="markdownIt-Anchor" href="#晒晒太阳"></a> 晒晒太阳</h3><p>​维生素D对正常前列腺组织生长和分化都起着重要的作用，如果提高血液中维生素D的代谢物，可大大降低患前列腺癌风险，对老年人尤为明显。研究发现，血清中Vitamin D含量高可以降低多种乳腺癌、结肠癌、直肠癌、前列腺癌等多种肿瘤复发危险和死亡危险。</p><p>​牛奶、鸡蛋、鱼和肉里面有维生素D，且维生素D也可以通过晒太阳在皮肤中合成，尤其是春冬天，每天要半个小时接触太阳。</p><blockquote><p>资料来源书籍《你是吃出来的》</p></blockquote><h2 id="可选项"><a class="markdownIt-Anchor" href="#可选项"></a> 可选项</h2><h3 id="维生素b族的补充"><a class="markdownIt-Anchor" href="#维生素b族的补充"></a> 维生素B族的补充</h3><p>​努力工作，到处跑，脑子一直转会消耗大量能量，也要消耗大量维生素B族，缺乏维生素B族时会出现上火，记忆力下降，消化不良；或者眼结膜充血，烦躁，口腔溃疡情况。</p><p>​维生素B族主要来自<strong>动物肝脏</strong>，蛋类，奶类，绿叶蔬菜和等，如果每周会吃一些动物肝脏，可以补充较多维生素B族。但是动物肝脏里的嘌呤比较高，体检容易尿酸高，高尿酸容易痛风，所以不能吃太多。也可以每天补充一粒维生素B族，但这是下策。</p><h3 id="鱼油"><a class="markdownIt-Anchor" href="#鱼油"></a> 鱼油</h3><p>​鱼油的功效虽然很好，对降低血压，保护血管，维持大脑和视网膜生理作用等，</p><p>​但是普通的鱼油从千万条鱼中提炼出来，基本都是含有重金属比如汞，铬，铅等</p><p>鱼油的选择还挺烦的：</p><p>​首先是EPA/DHA（omega-3不用管是什么含义）要占到70％以上，30％和60%纯度的基本起不到什么作用，EPA对血管好有降血脂血压功效，DHA对改善记忆力好。</p><p>​其次是经过认证，最好的是经过<strong>IFOS</strong>五星认证，比如意大利的omegor，金凯撒meaquor1000，GNC四倍铂金鱼油，但这些都比较贵，还有一些也是可以选的，这里没有调研。</p><p>​建议就是<strong>要么就不吃鱼油，多吃点菜籽油，鱼肉，坚果（这些也是很多omega-3）这些，要么就买好的鱼油</strong>，如果后面确实需要可以补充一些。</p><h2 id="忌讳"><a class="markdownIt-Anchor" href="#忌讳"></a> 忌讳</h2><h3 id="吸烟饮酒"><a class="markdownIt-Anchor" href="#吸烟饮酒"></a> 吸烟饮酒</h3><p>​爸爸以后不能吸烟，也要尽量避免吸二手烟。酒能少喝就少喝酒，有段时间我以为不会喝酒是自己的缺点，所以查阅了很多书籍关于酒的好处，想要以此来劝自己去学喝酒。但是查了很多关于喝酒的好处，却发现喝酒一个好处都没有，我还查证了一些可能性的“好处”。</p><ul><li><p>喝酒能“助眠”：虽然喝酒能帮助放松，<strong>但是会让人睡眠特别浅，大大降低睡眠质量</strong>，后果就是醒来后，脑子嗡嗡的，感觉没睡好，感觉自己断片了。</p><blockquote><p>资料来自书籍《我们为什么要睡觉》</p></blockquote></li><li><p>喝酒能让自己血管舒张，让人发热：但是平常普通的运动也可以让自己血管舒张，而且正是因为这个原因使得<strong>喝酒成为了最常见的高血压的诱因</strong>，因为喝酒后，酒精消散之后，血管就会从扩张变到回缩，<strong>让自己的血压发生较大的波动</strong>，长期会导致高血压</p></li></ul><p>喝酒除了会导致高血压之外，还会对肝脏造成损伤，我们一家人都是没有<strong>乙醛去氢酶</strong>，所以更容易伤肝。</p><h3 id="肉类尤其是加工肉"><a class="markdownIt-Anchor" href="#肉类尤其是加工肉"></a> 肉类（尤其是加工肉）</h3><ul><li>加工肉</li></ul><p>​小时候奶奶总是在快煮熟的饭上面放一些腊肉，腊肉饭的香味成为童年的美好回忆。但是查找的资料都显示吃加工肉（如香肠、培根、火腿、<strong>牛肉干（每年过年爸爸都会买较多牛肉干）</strong>、腌牛肉，以及其他烟熏、盐渍、发酵或腌制的肉类）会<strong>提高腹部癌变（结肠癌，直肠癌等）的风险</strong>，这是直接关系到爸爸病情的后续走向的，所以要严重关注。</p><ul><li>红肉</li></ul><p>​其次，也有资料说吃较多红肉（即牛肉、猪肉、羔羊肉、小牛肉、羊肉、马肉、山羊肉）会增加结肠癌的风险，但是这些都没有直接证据，没有上面的加工肉那么有直接证据，所以也要限制性摄入</p><p>​也就是说，猪肉牛肉也是可以吃的，但是要限量（最多不能超过2两，每天的蛋白质可以通过喝牛奶（奶粉），吃鸡蛋，鸡肉鸭肉，鱼肉，坚果等补充）但是加工肉酒绝对不能再吃了</p><h3 id="霉变食品"><a class="markdownIt-Anchor" href="#霉变食品"></a> 霉变食品</h3><ul><li><p>过餐的青菜</p></li><li><p>葵花子（坏的）</p></li><li><p>保存不当的茶叶</p><p>​普洱茶里面的黄曲霉素是所有茶叶里面相对最多的，有些低价普洱茶采用湿仓储藏陈化，湿度高，普洱茶更容易变黑，看上去和常年储藏的茶叶外表类似。但是这样会滋生大量黄曲霉素。</p><p>​正常保存情况下，其他茶叶也容易受潮而滋生黄曲霉素。</p><p>​<strong>所以为了以防万一，要少喝普洱茶，少喝陈茶</strong></p></li></ul><h3 id="高油高盐"><a class="markdownIt-Anchor" href="#高油高盐"></a> 高油高盐</h3><ul><li>油炸类</li><li>炒菜过咸</li></ul><h3 id="糖尿病"><a class="markdownIt-Anchor" href="#糖尿病"></a> 糖尿病</h3><p>​糖尿病和胰岛素抵抗也会提高大肠癌的发病率，糖尿病患者发生大肠癌的风险比非糖尿病患者高得多。糖尿病患者要控制好血糖，定期体检。</p><blockquote><p>资料来源：《曾医生让你早知道》</p></blockquote><h3 id="过辣"><a class="markdownIt-Anchor" href="#过辣"></a> 过辣</h3><p>​辣椒可以吃一点，但是以后要少吃，辣的感觉本质是一种痛感，吃辣椒暂时没查到对<strong>结肠</strong>会有什么影响，但吃辣容易刺激胃部，会对<strong>胃部</strong>有影响，所以要少吃。</p><h3 id="浓茶"><a class="markdownIt-Anchor" href="#浓茶"></a> 浓茶</h3><p>​浓茶会刺激胃部，所以基本就不要喝浓茶了，浓茶会刺激胃黏膜，对<strong>胃部</strong>不好，而且浓茶其他效果也不好</p><p>可以尝试每天喝茶控制在三杯左右，且不喝浓茶</p><h2 id="定期检查"><a class="markdownIt-Anchor" href="#定期检查"></a> 定期检查</h2><p>​<strong>一旦出现了肠息肉，那么以后长息肉的概率也会增加</strong>，所以一定要定期做肠镜检查，尽早发现肠息肉，尽早切除</p><p>​除了肠镜之外，还需要检查肿瘤标志物等</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;改善肠胃饮食建议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#改善肠胃饮食建议&quot;&gt;&lt;/a&gt; 改善肠胃饮食建议&lt;/h1&gt;
&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Perspectives</title>
    <link href="http://example.com/2022/10/19/Perspectives/"/>
    <id>http://example.com/2022/10/19/Perspectives/</id>
    <published>2022-10-19T13:12:28.000Z</published>
    <updated>2022-10-26T03:10:30.193Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><h2 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h2><span id="more"></span><h2 id="研究问题"><a class="markdownIt-Anchor" href="#研究问题"></a> 研究问题</h2><h3 id="研究背景简要介绍"><a class="markdownIt-Anchor" href="#研究背景简要介绍"></a> 研究背景(简要介绍)</h3><h3 id="研究问题或解决技术问题描述需定位和描述清晰"><a class="markdownIt-Anchor" href="#研究问题或解决技术问题描述需定位和描述清晰"></a> 研究问题或解决技术问题描述（需定位和描述清晰）</h3><h2 id="研究现状"><a class="markdownIt-Anchor" href="#研究现状"></a> 研究现状</h2><h3 id="围绕研究问题进行相关研究成果列举注明参考文献"><a class="markdownIt-Anchor" href="#围绕研究问题进行相关研究成果列举注明参考文献"></a> 围绕研究问题，进行相关研究成果列举（注明参考文献）</h3><h3 id="研究现状总结及现有研究仍然存在不足或问题"><a class="markdownIt-Anchor" href="#研究现状总结及现有研究仍然存在不足或问题"></a> 研究现状总结，及现有研究仍然存在不足或问题</h3><h2 id="思路特色"><a class="markdownIt-Anchor" href="#思路特色"></a> 思路特色</h2><h3 id="与现有研究技术手段不同之处"><a class="markdownIt-Anchor" href="#与现有研究技术手段不同之处"></a> 与现有研究（技术手段）不同之处</h3><h2 id="关键问题技术点"><a class="markdownIt-Anchor" href="#关键问题技术点"></a> 关键问题/技术点</h2><h3 id="围绕研究题目提炼出需要解决的几个关键问题点技术点"><a class="markdownIt-Anchor" href="#围绕研究题目提炼出需要解决的几个关键问题点技术点"></a> 围绕研究题目，提炼出需要解决的几个关键问题点/技术点</h3><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><h3 id="总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"><a class="markdownIt-Anchor" href="#总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"></a> 总体解决方案（最好能画一个总体方案图、或有一段描述清楚总体思路）</h3><h3 id="每个问题点技术点分别的解决方案或模型设计"><a class="markdownIt-Anchor" href="#每个问题点技术点分别的解决方案或模型设计"></a> 每个问题点/技术点分别的解决方案或模型设计</h3><h2 id="实验设计结果分析"><a class="markdownIt-Anchor" href="#实验设计结果分析"></a> 实验设计&amp;结果分析</h2><h3 id="场景选择-实验设计-指标选取"><a class="markdownIt-Anchor" href="#场景选择-实验设计-指标选取"></a> 场景选择、实验设计、指标选取</h3><h3 id="实验结果分析"><a class="markdownIt-Anchor" href="#实验结果分析"></a> 实验结果分析</h3><h2 id="论文结论"><a class="markdownIt-Anchor" href="#论文结论"></a> 论文结论</h2><h3 id="得出文章结论"><a class="markdownIt-Anchor" href="#得出文章结论"></a> 得出文章结论</h3>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt; 
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;/h2&gt;
&lt;h2 id=&quot;关键词&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关键词&quot;&gt;&lt;/a&gt; 关键词&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Blockchain technology in Named Data Networks: A detailed survey</title>
    <link href="http://example.com/2022/10/11/Blockchain-technology-in-Named-Data-Networks-A-detailed-survey/"/>
    <id>http://example.com/2022/10/11/Blockchain-technology-in-Named-Data-Networks-A-detailed-survey/</id>
    <published>2022-10-11T09:01:44.000Z</published>
    <updated>2022-10-26T03:10:30.192Z</updated>
    
    <content type="html"><![CDATA[<p align="right">NDN网络中的区块链技术：详细调查</p> <h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>​随着大规模的新应用和在线服务的出现，互联网的未来设计将有新的要求和影响，如兼容移动性、可扩展性、可靠性和安全性。命名数据网络（NDN）是最有前途的未来互联网架构范式，它专注于内容驱动的通信。与传统的IP网络不同，基于内容的命名数据网络（NDN）<mark>可以快速检索和传输内容</mark>。<mark>区块链技术已被广泛用于去中心化的支付、资产管理、医疗保健和云计算等</mark>。区块链提供了一个去中心化的分布式解决方案，在不可靠的网络中保持一致和可靠的记录，而不需要中心化的权威。然而，==区块链技术在IP上仍有一些严重的问题，如缺乏分层访问的效率。在NDN上使用区块链技术解决了这些问题，提供了一个去中心化的系统并简化了架构。==在本文中，我们首次对区块链技术在NDN中的应用进行了详细而全面的调查。最后，还讨论了一些研究挑战和关键问题。</p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><h2 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h2><p>NDN ，ICN ， Internet ，Named Data Networks ，Blockchain technology</p><span id="more"></span><h2 id="研究问题"><a class="markdownIt-Anchor" href="#研究问题"></a> 研究问题</h2><h3 id="研究背景简要介绍"><a class="markdownIt-Anchor" href="#研究背景简要介绍"></a> 研究背景(简要介绍)</h3><p>​因为每天都有大量的数据产生，互联网的使用从简单的通信到信息的传播已经发生了巨大的变化。互联网协议（IP）被计划用于点对点通信（Saxena等人，2016）。然而，现在它被广泛用于在互联网上分发内容。与作为非生产性广播内容手段的电话通信类似，现有的互联网架构与今天的使用方式不相符合。IP对话特征是由负责命名通信端点的IP数据报指定的，即IP源和IP目的地。今天的互联网架构是四十多年前为一小部分研究人员设计的，用于连接多个异构网络。当时，没有人预测到互联网在80年代末和90年代初的普及。现在，人们使用互联网的目的各不相同，从网络浏览到内容传输。设计用途之间的不兼容强调了IP架构的局限性，促使研究人员寻找新的解决方案。有了这么多的设备，==第一个问题是分配独特的IP地址的可用性。==尽管网络地址转换（NAT）和IPv6的引入解决了这个问题，但是考虑到互联网的使用不断增加，这还不够。此外，<mark>从隐私和安全的角度来看，现有的互联网架构由于其设计中的一些安全问题</mark>，甚至不能保证几个基本要求，如数据完整性、数据保密性或来源认证（Haibo等人，2010）。考虑到上述原因，研究人员专注于设计一个新的互联网架构，以尽快取代现有架构。</p><p>​近年来，以信息为中心的网络（ICN）对科学界来说变得越来越重要，因为许多研究项目已经在命名数据网络（NDN）中实现（Djama等人，2019）。对高效和可扩展内容分发的需求不断增长，激发了基于未来互联网架构的名称数据对象（NDO），称为ICN（Ahlgren等人，2012）。它是一种新的网络通信模式，以信息为中心，而不是以主机为中心。在ICN中，端点只能发出指定内容名称的请求，而不是内容的位置，带来不同的好处，<mark>如减少网络负载和延迟，固有的内容完整性</mark>（Fu等人，2018）和<mark>更好的移动性支持</mark>（Fang等人，2018）。ICN的概念于2001年在TRIAD项目中实现（Cheriton和Gritter，2000），在IP模型中引入了一个新的内容层。即使TRIAD的路由机制利用了内容名称，IP和TCP仍然是主干的。为了改进TRIAD，ICSI和加州大学伯克利分校在2006年提出了面向数据的网络架构（DONA）（Koponen等人，2007），它通过整合数据的持久性和真实性作为主要的基础设施目标来改进TRIAD，同时仍然高度依赖于主TCP/IP。2009年，Palo Alto研究中心（PARC）披露了以内容为中心的网络（CCN）项目（Jacobson等人，2009）。不久之后，美国国家科学基金会提出了未来互联网计划，为NDN铺平了道路（Zhang等人，2014）。CCN和NDN是两个主要项目，因为它们对ICN模型的高度关注影响了ICN架构设计（Conti等人，2019a）。</p><p>​NDN是一种ICN架构（Dai等人，2012年），与ICN的其他架构相比，由于其简单性和在架构上与CCN略有不同，在ICN社区获得了更多的兴趣（Ullah等人，2019年）。它开始于2010年，是美国国家科学基金会的研究项目，旨在创建未来的互联网架构，改变传统IP网络所使用的模式。NDN旨在取代现有的互联网架构，解决其根本问题，并通过提供网络缓存和固有的安全性为现有的通信场景提供更好的机制。NDN保持了目前基于互联网协议的架构。然而，它修改了其功能。==在NDN中，特定的消费者检索的是签名的内容，而不是传递到目的地的IP数据包。==初级研究和不同的可行性研究表明，NDN能够填补数据传输和互联网使用应用之间的空白（Aggarwal等人，2017）。</p><p>​NDN是未来的互联网架构，它的开发理念是跟踪不断增长的在线创建和传播的内容。==这个未来的互联网架构关注的是数据消费者想要什么，而不是要求的数据存储在哪里。数据可以存储在本地或最接近网络的节点的缓存中。==与TCP/IP不同，NDN架构中不需要主机节点的物理地址。由于通信不需要物理地址，DNS不需要给IP地址分配名称。</p><p>​虽然NDN标志着一种新的架构，但它的沙漏形状使它适合于当前的互联网，导致了一种简单而明确的演进策略。与IP类似，NDN甚至可以在IP上工作，同时一切都可以在NDN上运行。沙漏结构使互联网的原始设计强大而优雅。它专注于一个通用层网络，实现全球互联所需的最小功能。这种薄薄的尺寸一直是互联网发展的关键因素，使更高和更低层的技术在没有不必要的限制下进行革新。NDN保留了图1中所示的沙漏结构。与目前的IP架构类似，细腰是NDN的架构核心（Priya等人，2018）。然而，由于细腰利用数据名称而不是IP地址进行传输，以提供一套新的不重要的功能，这种表面上简单的变化导致NDN和IP的数据传输操作有本质的区别。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210122104053.png" alt="image-20221012210427711"></p><p>​区块链技术是最热门的技术之一（Lemieux，2016），如图2所示，代表了区块链技术在全球市场的规模。区块链技术作为一场技术革命广为人知，正在建立非凡的乐观和宣传。区块链技术作为一场技术革命而广为人知，正在建立非同寻常的乐观和宣传。它是由加密、签名的交易组成的分布式数字账本，聚集成块，保存着所有交易的记录（Zheng等人，2017）。区块链模型通过向所有参与者分发记录的副本，排除了对中央机构的要求（见图3）。传统的交易模式利用了客户-服务器网络架构。数据库的控制权仍在一个特定的机构手中，该机构负责验证客户的证书。权威机构负责数据库的行政和管理，确保数据不能被修改或删除。另一方面，区块链模式使用分散的控制，从而消除了与传统模式相关的风险。区块链技术在各个领域都有一些应用，如物联网、医疗保健、分布式云存储、房地产和政府。一项全球调查描述了区块链技术在制造业、政府、医疗保健、房地产、零售、媒体和旅游等领域的广泛应用（Anon，2018）。在区块链网络中，有人首先要求进行交易。每笔交易都会产生哈希值，它取决于当前以及之前的交易。即使是交易的轻微变化也会产生一个全新的哈希值。然后，该交易被广播到由节点组成的P2P网络。网络中的节点检查哈希值，以确保该交易没有被修改。这个网络通过使用已知的算法对交易进行验证。在交易被验证后，它与其他交易相结合，创建一个新的账本数据块。这个区块被添加到当前的区块链中，其方式不能被改变，从而完成了交易，如图4所示。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210122107998.png" alt="image-20221012210727915"></p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210122107542.png" alt="image-20221012210738486"></p><p>​图四没什么用，不贴了</p><p>​区块链技术的发展是一个类似于互联网出现的范式转变事件。最近，通过NDN的区块链技术已经变得非常流行(Mahmoud et al.,2019). Fig. 5介绍了NDN中区块链技术的研究趋势。许多研究人员强调在NDN中整合区块链技术的重要性和好处，并证明NDN可以满足特定区块链应用的要求。本调查的重点是NDN架构与区块链技术的整合。表11列出了本文中使用的所有缩写。</p><p>在本文中，我们将研究区块链技术在NDN中的应用。该文件组织如下。在第2节，我们将介绍NDN架构和协议设计原则。在第3节中，我们将详细讨论区块链技术。在第4节中，将讨论区块链技术对NDN的意义。第5节介绍了区块链技术在NDN架构中的应用的全面调查。第6节将介绍关键问题和开放性挑战，第7节将对本文进行总结。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210122110203.png" alt="image-20221012211035161"></p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210122111095.png" alt="image-20221012211107005"></p><h3 id="研究问题或解决技术问题描述需定位和描述清晰"><a class="markdownIt-Anchor" href="#研究问题或解决技术问题描述需定位和描述清晰"></a> 研究问题或解决技术问题描述（需定位和描述清晰）</h3><p>这篇文章主要是研究区块链技术在NDN中的应用。是一个综述论文</p><h2 id="研究现状"><a class="markdownIt-Anchor" href="#研究现状"></a> 研究现状</h2><h3 id="2-ndn架构"><a class="markdownIt-Anchor" href="#2-ndn架构"></a> 2. NDN架构</h3><p>​NDN是一种数据驱动的网络模型，它基于基于内容的网络理念。NDN范式解决了当前基于IP模式的许多问题（Rehman等人，2016），包括网络负载平衡、IP耗尽和网络开销。NDN的愿景是通过改变IP沙漏腰部的命名数据来重塑IP堆栈，通过位于腰部的不同网络技术进行连接。NDN架构强调的是数据安全而不是通道安全。<mark>NDN的数据包有内置的安全性，因为每个数据包都有数字签名，它的名字将它们绑定在一起。加密技术和数字签名被用于隐私和认证。每个数据包中的签名都在数据包的名称和内容之上。应用程序可以通过加密控制数据访问，密钥分配可以通过加密数据包的创建和发送安全地进行</mark>（Anon，2014）。这将数据的安全边界限制在应用程序的范围内。NDN中以数据为中心的安全也支持基础设施和内容访问控制的安全。内容认证可以通过不认证内容或名称，而是认证它们之间的联系来完成（Jacobson等人，2009）。根据应用的不同目的，NDN数据包中的名称被广泛覆盖，包括通信端点、内容对象名称等。通过这些不同类型的数据包名称，NDN可以满足不同应用的要求，如内容分发和端到端的通信。NDN集成了基本的架构重点：数据安全本身的构建、自组织网络流量、自适应路由以及转发能力（Chen等人，2016）。</p><p>​2.1 NDN包</p><p>​在这个架构中，有两种类型的数据包：一种是兴趣包，另一种是数据包（Zhang等人，2014），如图6所示。兴趣包由所需的内容名称和一个nonce组成，以提供一个唯一的标识符。数据包由一个特定的有效载荷组成，以解决所需的关注。消费者在兴趣包中放置所需内容的名称，并将此兴趣传递给网络。路由器利用这一名称将兴趣传递给数据生产者。一旦兴趣包到达拥有所需数据的节点，该节点将返回一个数据包，其中包含名称和内容，以及绑定两者的生产者密钥的签名。无论是数据包还是兴趣包，都不需要有主机或接口地址（Zhang等人，2014）。相反，路由器根据数据包中包含的名称将感兴趣的数据包传送给数据生产者，并根据每一跳的兴趣所定义的PIT的状态信息将数据包传送给消费者。这种兴趣包和数据包的规律性使得逐跳控制循环，从而消除了源和目的地概念的要求来传递数据，这与IP中的端到端模式不同。</p><p>​2.2 NDN路由组件和转发方法</p><p>​NDN路由器管理三个数据结构（Tariq等人，2019）。转发信息库（FIB）：一个路由表，用于引导兴趣到数据，一个待定兴趣表（PIT）：用于跟踪待定请求以及相应的接口和内容存储（CS）：临时存储进入的数据包（Zhang等人，2010）和一个转发策略模块。转发方式在NDN的灵活性和效率方面起着重要作用。转发策略是一套传输数据和兴趣数据包的规则和策略。转发策略也可以在一些特定的条件下丢弃兴趣包，如上行链路拥堵或特定兴趣包被怀疑是拒绝服务攻击的一部分（Anon，2019）。转发策略利用转发管道中的一系列触发器，并分配给名称前缀。通过利用多种NDN路由能力，自适应策略可以沿着最佳路径传输利益包信息，同时避免拥堵并保持负载平衡。一旦感兴趣的数据包到达NDN路由器接口，就会执行一个顺序的过程。为了接收数据，消费者发送一个感兴趣的数据包，其中有一个指定所需数据的名称。路由器记住了请求数据的接口，然后通过在其FIB中查找名称来返回兴趣包。当兴趣数据包到达包含所需数据的节点时，包含数据名称和内容的数据包被返回，同时还有一个带有产品密钥的签名。这个数据包以与兴趣包相反的方式遵循相同的路径。兴趣包根据兴趣包中列出的名称路由到数据生产者，而数据包则根据路由器上每一跳的兴趣识别的状态信息返回。路由器将所有等待数据包返回的兴趣存储在PIT中。当收到同一数据的几个兴趣时，只有第一个兴趣包被发送到数据源。PIT的每个条目包括兴趣名称，以及收到相同名称的兴趣的接口集。当一个NDN节点收到请求某些信息的兴趣包时，它首先在其内容存储（CS）文件中寻找对应于所需名称的数据。如果找到了匹配的内容，兴趣包就会被删除，请求的信息就会作为同名的数据包提供给从处理器收到的接口。如果在CS中没有找到所请求的内容，则检查PIT表以寻找相应的条目（Aboodi等人，2019）。匹配意味着已经提交了一个类似的请求。</p><h3 id="区块链框架"><a class="markdownIt-Anchor" href="#区块链框架"></a> 区块链框架</h3><p>区块链框架的高层图示见图7 该框架被细分为数据层、网络层和应用层（Gao等人，2018）。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210122121407.png" alt="image-20221012212151345"></p><p>​数据层</p><p>​从数据结构的角度来看，区块链是一个连接的数据块的列表，这些数据块是使用加密哈希值连接和验证的。它是一个极大的复制的、去中心化的数据库，交易以区块的形式组织在P2P网络中（Alharby和van Moorsel，2017；Nasir等人，2018）。区块链的数据结构DS可以用区块链的链接列表的形式来表示，其中交易的请求。区块链的数据结构有两个主要组成部分，链接列表和指针。指针是指向其他变量位置的变量，链式列表表示链式区块的列表，链上的每个区块都有数据以及指向前一个区块的指针。一个区块有链上前一个区块的哈希值，通过时间戳、nonce和Merkle树哈希的交易集合（Nakamoto，2019）。Merkle树的形式是哈希值的二进制树。每个区块都有Merkle根的哈希值与数据，例如，时间戳、前一个区块的哈希值、区块的版本号、nonce和当前的复杂度目标，如图8所示。Merkle树为区块链技术提供了完整性、不可辩驳性和安全性。默克尔树与共识算法和密码学一起，是区块链技术的根源。</p><p>​根据区块链的类型，数据被存储在区块中。加密哈希算法（SHA 256）可以生成一个固定长度的数据哈希值（Clincy和Shahriar，2019）。哈希值有助于有效识别区块，也有助于识别对区块的任何修改。为了保证数据记录的完整性和安全性，交易在区块链上进行数字签名。数字签名确保了完整性，因为加密的信息也被签名。因此，任何修改都会使签名无效。发件人的身份也通过数字签名的方式得到保障。数字签名与用户有合法的联系，不能被撤销。</p><p>​网络层</p><p>​网络层也被称为P2P层，它负责节点间的通信。它处理披露、交易以及区块传播。网络层的目的是促进区块链的通信环境。这些包括依赖于P2P网络和IP协议的去中心化网络，锁定和解锁内容，以及用于分布式协议的区块有效性的共识方法。网络层也促进了区块链的更新以及在客户之间的分配。区块链上的节点执行交易。有两种类型的节点，分别是轻型节点和完整节点。完整的节点保证交易的确认和批准，采矿以及共识规则的授权。他们负责保持对网络的依赖性。光节点保留区块链的头，可以发送交易。共识协议是区块链平台存在的枢纽。共识层是区块链最基本和最根本的层，负责批准区块，请求区块，并保证每个人都同意它。共识机制使网络中的所有节点同步。工作证明（PoW）、获取证明（PoS）、真实性证明（PoA）、烧毁证明（PoB）、实用拜占庭容错（PBFT）和具有失效时间证明的可信硬件（PoET）是一些共识机制。共识保证了所有的节点都同意真相，并确保权力保持分散和分布，使参与的节点之间一致承认真相。对于有数字货币的区块链来说，共识还可以补偿批准交易的节点，以及维护区块链网络。</p><p>​应用层</p><p>​应用层展示了不同的应用，可以结合区块链使用其连续的账本，在不信任的节点之间达成共识，加密组件和智能合约。应用层由链码、dApps和智能合约组成，可分为两个子层，即执行层和应用层。应用层有终端客户使用的应用程序，与区块链网络合作。它包含API、脚本、框架和用户界面。执行层是子层，它由底层规则、智能合约以及链上代码组成。这个子层有被执行的真实代码，以及被执行的规则。交易从应用层传播到执行层；此外，交易在语义层被批准以及执行。</p><h3 id="区块链技术对ndn的意义"><a class="markdownIt-Anchor" href="#区块链技术对ndn的意义"></a> 区块链技术对NDN的意义</h3><p>​某些技术的出现引起了研究人员的注意。NDN允许高效检索数据，区块链保证数据安全。根据一些研究者的观点，在目前的IP中应用区块链技术并不是一个好的决定。相反，在NDN上部署区块链技术可以在效率方面提供更好的性能（Gebraselase等人，2019）。</p><p>​NDN是一个很有前途的未来互联网架构，这使得允许在NDN上实施区块链技术成为一项基本任务。==对于NDN框架来说，提供可靠的内容是很重要的，NDN中的区块链在这方面可以提供帮助。==区块链为参与者提供了一种新的方式，在不信任的网络中保持一致和可信的数据库，而不需要任何集中的权威。然而，真正的区块链系统仍然有一些严重的问题。</p><p>​<mark>TCP/IP上的区块链并没有提供内置的多播支持。在传统的区块链中，同质化的节点之间建立连接是一个挑战。这也导致了漫长的同步时间。NDN上的区块链通过提供一个完全去中心化的系统，解决了这个IP网络问题。主要的设计决定指的是信誉的计算和在网络上分配的过程。因此，信任模型被分为集中式或分散式模型。在前一种情况下，中央信用机构负责收集评级、计算、存储和公开与网络中实体的信誉值。</mark></p><p>​虽然这种方法限制了计算的复杂性，因为没有必要让每个节点评估声誉，但对交换资格和声誉值所产生的开销成本有补偿。虽然这种方法限制了计算的复杂性，因为没有必要让每个节点评估信誉，但对交换资格和信誉值所产生的开销成本是有补偿的。这种方法的另一个重要缺点是，统一的、可信的实体代表了一个故障点。而在去中心化的方法中，评级是由每个节点独立计算的，然后可能通过广播协议，以P2P的方式分发到各节点。这就消除了单点故障的问题，但它要求进行计算和提供信誉值的单个节点也可以是可靠的。</p><p>​区块链技术还存在严重的可扩展性问题，威胁着它在全球的应用。验证交易和分发更新导致了重大的数据开销。为了解决这些问题，区块链技术可以作为一种解决方案被整合到NDN网络中，因为它在分布式宣传信誉值的同时，还提供了中央机构的信心和可信度。</p><p>​图9展示了区块链技术在NDN中的整合。每次兴趣数据包被广播，交易被请求，矿工在生成区块之前都会验证和记录它们。NDN上的区块链技术提供交易和区块组播。==基于区块链的方法，如基于信誉的区块链，可以通过对现有系统的补充工作，加强和改善NDN的安全和信任。==NDN的设计是对网络上的所有数据进行私有和公共及密钥加密，这与区块链的概念一致。确保数据安全并进行认证也是区块链创造有价值的互联网的关键（LEI，2018）。<mark>信任管理在商业领域的部署拓宽了P2P网络的范围。这种网络的主要特点是对等人需要确定其他客户的意图是恶意的还是可靠的（Kapetanidou等人，2019）。信任管理系统的目的是只授权非恶意的对等人积累良好的声誉。这使得非恶意对等体很容易识别恶意对等体并将其从交易中移除（Hamlen和Thuraisingham，2007）。与在线声誉模型不同，P2P网络的去中心化设计需要一种分布式方法。区块链在ICN或NDN上可以实现一个高效、简单的去中心化系统。区块链技术在NDN上可以减少传输开销、网络流量冗余、拥堵并提高效率。</mark>（其实不同的NDN厂商之间可以利用这种声誉机制）</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210122141423.png" alt="image-20221012213441594"></p><h3 id="在ndn中实施区块链技术"><a class="markdownIt-Anchor" href="#在ndn中实施区块链技术"></a> 在NDN中实施区块链技术</h3><p>​NDN和区块链大多被独立研究。然而，近年来见证了区块链技术在不同领域，即安全和隐私、网络、物联网、移动性和其他领域与NDN的整合。区块链主要是为TCP/IP设计的。在TCP/IP中，如果一个节点向多个节点传输数据，它需要将数据封装在一个数据包中并单独发送给所有节点，从而带来不必要的数据传输。NDN利用网内缓存（Guo等，2019），有利于改善区块链应用的基础广播。NDN的以数据为中心的方法使区块链中的有效记录分布以及熟练的区块同步。在NDN中，数据是从整个网络中获得的，而不是从某个特定的节点或位置。NDN上的区块链技术消除了TCP/IP上的区块链中轻节点和全节点的概念，从而平等对待所有的节点。<mark>这解决了当前分布式账本系统的主要安全漏洞，即轻节点完全依赖全节点检索和返回数据，使其暴露在全节点的恶意行为之下（Vasavada，2019）</mark>。NDN上的区块链技术允许高效的数据分配。</p><p>​纳入的研究中使用了不同类型的区块链，如私人、公共和财团。这是区块链的三种主要类型（Mohanta等人，2019；Hui等人，2019）。公共区块链是一个无权限、非限制性的分布式账本框架。任何可以上网的人都可以登录区块链平台，成为认证的节点以及成为区块链的一部分（Anoaica和Levard，2018）。私有区块链是经过许可或限制的区块链，只在封闭的网络中运作（Lu，2018）。私有区块链用于企业和一个组织，其中只有选定的成员是区块链网络的成员。联合体区块链是一种半分散的区块链类型，其中有一个以上的组织运行区块链网络（Aras and Kulkarni, 2017）。在这种区块链类型中，不止一个组织可以作为节点运行，并交易信息或进行采矿。表1总结了所纳入的研究中用于在NDN上实现区块链技术的区块链类型。</p><p>​公共区块链和私有区块链是使用最多的应用类型，因为31%（9篇）的论文使用了私有区块链，同样，31%（9篇）的论文使用了公共区块链。联合体区块链是相对较新的区块链类型，只有7%（2篇）的论文使用。然而，如图10所示，31%的论文没有提到论文中使用的区块链类型。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210122200379.png" alt="image-20221012220028317"></p><p>​<img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210122200541.png" alt="image-20221012220044444"></p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210122201400.png" alt="image-20221012220106313"></p><p>5.1安全与隐私</p><p>​为了确保ICN以及其他类似架构中内容的安全分发，作者引入了一种基于名字的分散安全机制（Fotiou和Polyzos，2016）。Fotiou等人利用他们之前的工作，提出了基于名字的分散安全机制，旨在确保ICN以及其他类似架构中的内容分发（Fotiou and Polyzos, 2015）。这种机制得益于基于身份的加密（HIBE），以提供内容存储授权，验证内容的来源和保护内容的完整性。这个解决方案不需要像以前的模式那样处理安全问题。此外，该解决方案使用区块链技术来提供系统参数。该方案是在Namecoin提供的区块链上实现的。该方案相当通用，可以整合到不同的ICN架构，或任何类似的系统中。在原型实现中，作者使用了一个基于IP的软件来与区块链进行交互。对于未来的工作，建议对基于ICN的区块链实施进行探索和分析。</p><p>​Khandelwal等人介绍了一种基于名字的分散安全机制，以确保ICN和其他类似架构中内容的安全分布。提出的机制利用HIBE（基于身份的分层加密）来实现内容存储分配、内容来源验证和内容完整性的保护。HIBE指定了私钥发生器（PKG），并创建与每个身份对应的私钥。它使用内容名称作为HIBE的公钥，并为每个内容所有者考虑1个PKG，消除了密钥托管的问题，并利用区块链技术来部署系统参数。该机制是由Namecoin2使用区块链实现的。它是一个基于比特币加密货币的开源注册和转让系统。为了实现一个原型，作者使用了Namecoin的基于IP的软件，与区块链进行交互（Khandelwal等人，2018）。</p><p>​<mark>Li等人提出了BICN；一种基于区块链的信任增强监控机制，用于整个ICN内容交付过程（Li等人，2019）。该机制可以忠实地反馈区块链中ICN节点的行为记录，这对于保证对恶意记录的监控至关重要。为此，设计了区块链中自证和人可读名称之间的信任富集映射。因此，这两种形式的名称可以方便地相互交替使用，以满足用户、发布者和ICN节点的不同要求。为了在基于BICN的智能电网中实现能源的安全数据传输，我们进行了一个案例研究。所进行的实验的数值结果验证了这个建议是一个有前途的解决方案。</mark></p><p>​表2全面总结了区块链技术在NDN上在内容安全方面的实施。</p><p>5.1.2密钥管理</p><p>​在这项研究中，Lou等人（2018）利用区块链的优势，提出了一种基于区块链的NDN密钥管理方案，以解决站点之间的互信问题。同时对NDN中的公钥内容对象及其存储、认证和撤销的模式进行了重新设计。对密钥内容对象的重新设计提供了一种有效的方法来执行区块链中的哈希查询。在这个方案中，更扁平的层次结构减少了密钥签名和验证密钥的数量，与公钥密码学相比，计算成本更低。分析和评估结果表明，所提出的方案可以支持更少的验证数量并提高验证效率。对于未来的工作，作者将专注于该方案在物联网中的实施，并发现一个更有效的公钥哈希管理机制。</p><p>​为了解决传统密钥管理系统中的Compromised CA问题，本研究中Yang等人（2018b）提出了BC-PKM；一种基于区块链的NDN公钥管理系统。BC-PKM得益于区块链技术的去中心化特性和防篡改特性。这个管理系统允许地理上和政治上不同的对象在共同的公钥数据库的状态上获得共识。BC-PKM的主要思想是为每个NDN命名空间创建一系列的公钥区块链，并将一个CA的权力分给几个维护公钥区块链的PKMiners。作者还证明，BCPKM可以抵御各种攻击，因为对手破坏了不到一半的所有公钥未成年人。作者还应用BC-PKM原型，在实践中验证其可行性和功能，发现它是实用和安全的。对于未来的工作，作者将在NDN的平台上实现所开发的原型，并研究高效的PKM区块链设计，将BC-PKM用于NDNS安全。</p><p>​为了解决密钥管理的安全挑战，Labbi等人（2018）提出了DPKI（Decentralized Public Key Infrastructure）作为一种先进的解决方案，利用区块链来应对CCN中与密钥管理和内容中毒有关的问题的缺点。本文介绍了基于区块链的PKI，作为一个有能力的解决方案来克服CCN中与密钥管理和内容中毒相关的问题。基于区块链的PKI是传统CA方法的一个可行的替代方案，提供所需的安全功能。人们已经看到，自主、分散、安全和可信的区块链能力非常适合CCN中公钥的存储和管理。这些能力允许获得内容，无论内容是如何获得的或从谁那里获得的，并在充分性、来源和重要性方面得到有力的评估。在区块链上创建公钥基础设施是传统CA和WoT方法的一个可行的选择，提供了理想的安全功能。</p><p>​表3全面总结了区块链技术在NDN上的密钥管理的实施。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210130930494.png" alt="image-20221013093021349"></p><p>5.1.3缓存安全</p><p>​<mark>在这项研究中，Tan等人（2018）提出了一种结合了xorcoding和区块链的新型模式，通过利用网络内的缓存来减少网络流量。ICN的访问框架允许合法用户访问所需内容。此外，只有授权用户可以只获得所需的内容块。除了用户的注册，所有的任务都提供给区块链来完成。解密信息被放入区块链，这样用户就可以随时随地得到这些信息。因为加入了区块链，CP可以通过保护用户权利的唯一序列和通过区块链来追踪泄漏。分析表明，该模型会有很好的性能。</mark></p><p>​在这项研究中，Li和Asaeda（2019）Ruidong Li和Hitoshi Asaeda已经确定了不同的攻击以及ICN中数据生命周期保护的设计要求。为了满足这些要求，提出了基于区块链的数据生命周期保护（BDLP），以管理智能合约和交易，使数据安全地用于网络内缓存。在BDLP框架中，数据坝区块链节点（DDBN），一个新的节点类型被整合，以控制本地的注册以及限制数据的流动，它也执行区块链和ICN之间的互动。 安全性分析和性能评估表明，BDLP可以满足设计要求，保护数据的生命周期。</p><p>​Roy等人（2019年）进行了一项研究，通过寻找不同的方法来利用数据缓存来改善挑战性环境中的网络性能。因此，本研究将模拟缓存攻击的结果扩展到真实的ICN。特别是，真实ICN上的DoS攻击的效率和可扩展性与模拟环境的结果进行了对比。在实验中使用了两种拓扑结构（网状和线性）、三种缓存替换策略（LRU、随机和FIFO）和两种缓存大小，并发现了一些影响网络性能的新因素。这些因素是基于网络的病毒、网络流量、基于网络带宽的数据包传输延迟和没有备份服务器的网络服务器攻击。即使在考虑了真实网络的因素后，也检查了与模拟得到的趋势，表明缓存攻击对小型网络的影响很大，对大型ICN的影响很小。</p><p>​表4全面总结了区块链技术在NDN上实现缓存安全的情况。</p><p>5.1.4隐私</p><p>​Lyu等人（2019）提出了基于区块链的安全访问控制（SBAC）框架，使内容提供者（CP）能够安全地控制内容的共享、审计以及撤销。这是一个基于区块链的访问令牌机制，通过访问令牌的转移以及访问交易，实现审计、共享和撤销内容的访问控制机制。提出了一个基于匹配的访问控制框架，以获得分层访问和有效的访问控制。访问令牌可以获得一堆资源，即使在其有效期内有任何变化，也能发挥作用。该模型继承了区块链的别名、防篡改和去中心化的特点，以平衡用户的匿名性和访问策略的隐私性。访问策略的隐私性通过将访问策略限制在拥有的CP和设计访问令牌的精确格式来保持。通过区块链的匿名性，用户的真实身份被隐藏。访问政策仅限于CP，因为每个CP负责建立和维护内容请求者（CQ）的访问政策，并且只在AccTokenx中标记相关信息。此外，尽管AccTokenx的一切都被发送并记录在任何实体都可以访问的区块链上，但对手无法知道AccTokenx传输路径以外的任何东西。通过这种方式，SBAC框架可以保证用户的匿名性和访问策略的隐私。同时，提出了布谷鸟过滤器，以提高验证期间访问令牌请求的有效性，并设计了一个缓存策略，以满足广义的ICN缓存。</p><p>表5全面总结了区块链技术通过NDN在隐私方面的实施。</p><p>5.2网络</p><p>5.2.15G</p><p>​由于频繁的请求和响应，隐私保护和巨大的能源消耗是两个主要问题。在这项研究中，Fan等人提出了一个基于区块链的方案来解决5G内容为中心的移动网络中的隐私问题（Fan等人，2017）。作者在用户和内容提供商之间应用了相互信任。系统中密钥管理的复杂性被大大降低。具体来说，他们使用了访问控制策略和加密技术的组合来确保用户数据的安全。只有能够满足访问策略要求的用户才被允许在云中存储加密数据。==作为网络中交换信息的节点，矿工可以有效降低网络拥堵程度，减少延迟。==表6全面总结了5G中通过NDN实现区块链技术的情况。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210130937397.png" alt="image-20221013093710324"></p><p>5.2.2无线传感网络（wsn）</p><p>​Shintaro Mori专注于构建一个基于ICN的WSN安全缓存机制（Mori, 2018）。为了实现上述机制，作者采用了公钥密码学技术和区块链技术，实现了安全的数据采集，并对交叉检查和分散的传感数据进行复制和存储。此外，他们还制定了一个协议，提出了一个信号处理程序来实现所提出的机制，并制定了统计模型。通过进行基于硬件和计算机模拟的不同实验，以数字形式展示了结果。</p><p>表7全面总结了在无线传感器网络（WSN）中通过NDN实施区块链技术的情况。</p><p>5.2.3车联网</p><p>​<mark>Khelifi等人（2018a）提出了一个基于信誉的区块链，以确保车辆环境中NDN的缓存数据。在提出的解决方案中，区块链被整合为基于NDN的VANET网络上的分布式、去中心化的可信平台。该模型的目的是在中间节点的缓存存储中只缓存可信的内容。消费者可以请求内容，并且只使用有效的内容，通过这种方式，通过提高区块链网络上的声誉来评估所服务的缓存商店的声誉。因此，缓存商店的声誉根据所服务的内容而增加或减少。结果表明，只有安全的内容才能在网络上被缓存和服务。图11.显示了研究的分类。</mark></p><p>​匹配执行方面的计算复杂性随着节点数量的增加而增加，从而使供需分配对所有节点来说都很耗时。为了解决Vehicular Named Data Networks（VNDN）中的内容共享问题，Chen等人利用区块链技术，为VNDN的内容交易开发了一个去中心化的安全系统（Chen等人，2019）。解决VNDN的内容共享问题，广泛涉及信息管理、信誉管理、数据供应以及需求匹配。设计的内容共享系统有一个双层区块链。底层节点通过广播他们在NDN范式中的需求来请求服务。上层节点发送他们的需求和供应，以便进一步匹配到最近的路边单元（RSU）。作者将需求和供应的平衡建模为一个匹配游戏。<mark>提出了一种信誉管理现象，以提供积极的服务。为了防止恶意节点传播虚假信息，设计了RES来整合到匹配模型中。仿真结果验证了该系统的有效性。在未来，作者愿意将他们的一对多分配游戏扩展到除了考虑客户的需求和服务器的供应之外的与外部的匹配。</mark></p><p>​表8全面总结了在车辆网络中通过NDN实施区块链技术的情况。</p><p>5.3Ad-hoc networks特设网络</p><p>​本研究Zhu等人（2018）给出了物联网中安全攻击的概要，以鼓励调查物联网的新解决方案。它提出了物联网的总结，并分析了在检索、缓存和数据传播方面的安全攻击。此外，作者还讨论了物联网安全的现有解决方案。最后，为了解决安全攻击问题，在物联网背景下讨论了区块链启用的解决方案（Swan，2015）。数值评估表明，安全攻击通过降低数据包的交付率和增加数据包的传输延迟来降低物联网的性能。</p><p>​Zhang等人（2019b）提出了一个有前途的分布式账本系统–Dledger。它建立在NDN架构之上，以呈现一个安全的账本，从而可以维护永久和不可逆的数据。<mark>沿着DLedger，实体不能反对或否认记录数据的存在、拥有和有效性，确保正常的商业运作。我们不使用工作证明（PoW），而是使用认证证明（PoA），因为其操作与物联网兼容，可以完成共识。通过使用PoA和DAG，即使是有限制的设备也可以通过提取和确认自己的记录来参与，从而提高数据的可用性、完整性和真实性。作者已经实现了DLedger原型，并通过理论分析和模拟结果对其进行了评估。结果表明，DLedger是一个可扩展的、强大的解决方案，有能力缓解可能的攻击情况和漏洞。</mark></p><p>​Lei等人提出了下一代区块链网络（NGBN）的框架设计（Lei et al., 2019a）。NGBN的主要特点是推动通信PHY层的上升，并推动应用层的下降，从而汇聚到一个叫做区块链网络层（BNL）的层。BNL背后的目标是有效地实现区块链代币经济，通过加入点对点合同，为未来十年预期的所有大数据和人工智能应用提供一个具有无限可扩展性、可用性以及可扩展性的P2P网状网络。作者在本文中的贡献有三点。首先是设计一个带有流数据库的CEP平台，包括整体结构、实现细节和功能块，并提出了NGBN框架的设计。更具体地说，提出了一个高效的基于NDN的网络，整合了物联网应用和现有的无线网络。最后，在针对智能交通的NGBN框架内研究了智能城市。未来的工作包括与几个合作伙伴在现场进行演示。</p><p>​考虑到NDN UAANETs（无人飞行器ad hoc网络）的安全威胁，Lei等人提出了IKCB（Interest-Key-Content Binding），按需验证和转发策略，以有效地找到中毒的内容。此外，他们还提出了一个基于NDN的许可区块链系统，并提出了一个可靠的自适应算法来达成共识，从而提供了一个去中心化的IKCB存储和识别内部攻击者。根据对结果的实验分析，该机制获得了较好的效率，其有效性和区块链系统可以满足UAANET的整体要求（Lei等人，2019b）。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210130941528.png" alt="image-20221013094138462"></p><p>​Zhang等人（2019a）提出了一种新的DLedger模型，与传统的账本系统不同。这是一个私有的、分布式的账本系统，用于试验太阳能网络系统，采用PoW而不是PoA来实现有效性。Dledger的设计采用了IOTA的理念来存储所有的交易记录。IOTA加密货币是在Tangle上形成的。它是一种分布式账本技术，基本上是一个DAG。IOTA表示，由于其无感交易以及低资源限制，因此对物联网是友好的。DLedger为客户和系统供应商提供信息透明度和可用性。DLedger利用NDN以内容为中心的设计，以高效、分布式的方式维护账本。通知协议和同步协议建立在NDN的基础上，并利用其固有的组播支持以及数据分布的特点，从而提高带宽的利用率，减少内容获取的延迟。原型实施的结果表明，PoA对于以内容为中心的网络基础设施和私人分类账系统来说是足够好的。</p><p>​Ahmad等人（2019年）提出了一个名为BINDN（支持NDN的车联网中的区块链）的新型架构，以解决车联网（IoV）的安全问题，并增强应用和服务的范围。BINDN支持NDN兼容的物联网中的区块链技术。它可以作为一个参考框架来设计利用区块链技术的NDN授权物联网的安全解决方案。作者强调了在NDN授权的物联网中整合区块链以在参与车辆网络中广播安全信息时所面临的重大问题和挑战。</p><p>​表9全面总结了在特设网络中通过NDN实现区块链技术的情况。</p><p>5.4其他</p><p>​在Jin等人（2017）中，作者介绍了BlockNDN，一个运行在命名数据网络上的比特币去中心化的账本系统。作者没有复制比特币的设计并在IP网络中盲目完成，而是提出了一种类似于ChronoSync的去中心化设计方法，并利用了NDN的架构优势。在BlockNDN中，命名涉及很多指定的语义。带有发送者状态的同步兴趣包被发送到生产者那里，给了更新数据集的简单技术。获得块数据的名称和块摘要使请求和检索更加简单。与通过TCP/IP的系统相比，最终的设计提供了更好的分散系统，同时增强了不良的通信现象，减少了广播的开销。</p><p>​Sedky和El Mougy（2018）提出了IP覆盖网络的替代方案，并实现了BCXP（以区块链为中心的交换协议），在命名数据网络之上的区块链网络的可访问层，以使用重大功能；各种区块链流量隔离，高效传播信息，并行支持多个区块链，同时允许完整性检查。BCXP高效地广播交易，部署速度比IP覆盖网络快10倍，网络流量过载减少14倍，传输速率比IP覆盖网络低3倍，随着网络的增长，性能也在蓬勃发展。仿真结果表明，BCXP减少了区块的传播延迟，降低了分叉机会，最小化了网络开销，并保持了网络的稳定性，允许更高的交易吞吐量和更低的区块时间。</p><p>​该研究Yang等人（2018a）采用基于NDN的服务进行数据管理，并应用联盟区块链技术进行安全的数据管理，采用分权式集中管理。作者努力克服网络空间中的集中管理和安全威胁问题。作者还强调了区块链在去中心化环境中的优势，所有用户都可以跟踪以及评估交易。这个新颖的系统通过使用识别器内容名称创建交易记录，并牢记用户的隐私。该系统使用雾计算作为网络拓扑结构，使用区块链技术作为标识符的分割和恢复方法。敏感的标识符也可以通过标识符的分割管理系统进行安全存储和管理。</p><p>​Commes等人在NDN上开发了一个多媒体共享应用，它反映了建立在TCP/IP上的Snapchat应用（Coomes等人，2018）。这项研究的重点是创建一个去中心化的应用程序，探索新的信任模型，并使用新的同步协议进行数据子集的同步。该设计旨在实现一个完全去中心化的设计，没有任何中央数据库来验证用户名或寻找朋友。该应用设计还允许用户验证彼此的数据，而不依赖公共批准。要使用该应用程序，寻找朋友是最重要的。一旦用户找到他们想要的朋友，有两种方式可以成为朋友。用户可以从他们的朋友那里获得新的内容，并可以与他们的一些或所有的朋友分享这些内容。对于朋友的公钥认证，Yu等人（2014）提出的信任网方案或Yang等人（2018b）介绍的基于区块链的公钥管理系统进行了探索。如果存储的公钥与签名不匹配，数据包将被丢弃，导致超时。</p><p>​Attia等人专注于基于物联网的区块链架构，用于监测医疗保健应用（Attia等人，2019）。作者首先探讨了物联网和区块链。这有助于确定Fabric Hyperledger作为区块链框架对医疗保健监控应用需求的好处。开发这个架构的目的是提供一个安全的远程监控系统。一些病人已经使用连接的设备进行了监测，检索到的数据已经被收集到区块链网络中。然后，收集到的数据将由有意义的名称而不是设备标识符来识别。这是靠NDN协议完成的，该协议也允许移动性。然后，研究重点是使用Fabric Hyperledger框架对区块链网络进行配置，并设计了一个GUI。作者通过实施实例验证了这种方法。对于未来的工作，作者愿意为一个完整的基于物联网的区块链框架实现更多的功能，以监测健康应用。</p><p>​Guo等人提出BoNDN来解决兼容性问题，使区块链在NDN的架构上得到应用。BoNDN遵循主要的NDN网络设计，将所有需要广播的区块链数据类型独立处理。作者特别依靠兴趣广播，以支持区块链交易的实时广播，因为其体积小，可以由兴趣包执行。还提出了一种订阅推送的方法来支持区块链区块广播，每个未成年人都会进行订阅，只要区块被创建，订阅者就会得到该区块（Guo等人，2019）。</p><p>​Wei等人（2019）提出了一种基于区块链的机制，用于租赁NDN中的资源，为NDN提供可靠的环境。通过公有链和许可链的结合，建立了一个可靠的、透明的市场。这种基于区块链的混合激励机制克服了传统拍卖机制的缺陷，从而在保证AP利益的前提下为CP获得最大的利润。在不频繁使用回程带宽的情况下，可以从接入点获得内容，并且内容可以被用户轻松验证。</p><p>​保护个人医疗信息的保密性及其版权是信息安全的一个重要问题。在Kuo和Shieh（2019）中，ICN架构被应用于创建跨域交换和保护个人医疗信息的版权授权。作者利用区块链机制创建了授权机制和认证的密钥协议机制，为每个区块链和数据连接创建了一个标准流程。为此，作者设计了一种机制，利用ICN架构创建和授权个人医疗信息的交换。为ICN环境设计的个人医疗记录可以随时随地被访问，并可以与不同的医疗专业人员安全地共享，在即将到来的高速网络中提供由各医疗单位批准的数据。</p><p>​Conti等人（2019b）介绍了基于区块链的BlockAuth，用于ICN场景下的移动性管理，以分布式的方式为移动生产者提供安全、快速的认证技术。作者声称BlockAuth是一个新颖的框架，通过使用区块链技术为ICN中的移动管理场景提供安全、快速和可靠的认证。它对产品前缀进行认证，并迫使他们只表达他们被允许发布的前缀的原始路由更新。作者通过对路由器的吞吐量、生产商的认证延迟和存储成本等参数进行评估，证明了其效率和可行性。此外，该框架能够处理几种网络攻击；前缀劫持攻击、拒绝服务攻击、附加攻击、分布式拒绝服务攻击、重放攻击、丢弃数据包攻击和虚假信誉，区块链和移动网络特别容易受到这些攻击。</p><p>表10全面总结了在其他领域（资源租赁、移动性等）通过NDN实施区块链技术的情况。</p><p>​对不同领域研究分类的分析结果显示，区块链技术在网络和安全与隐私领域的实施贡献最大，网络领域有10项研究，安全与隐私领域有10项，其次是其他领域（包括医疗、资源租赁等），有9项研究（见图12）。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210130953685.png" alt="image-20221013095337622"></p><ol start="6"><li>区块链在NDN上的关键问题和公开研究挑战</li></ol><p>在本节中，我们将讨论在NDN上实施区块链可能产生的几个挑战。</p><p>6.1安全和隐私性挑战</p><p>​即使在NDN上实施区块链技术可以防止不同的攻击，但对于研究者来说，仍有许多开放性问题需要探讨安全和内容缓存问题（Zhu等人，2018）。区块链在物联网NDN方面的实施面临着与物联网间歇性和动态连接特征有关的挑战。==另外，区块链需要大量的存储。需要检测和预防一个综合的，以及轻量级的攻击机制，适合物联网NDN的限制计算和存储容量，以及能够满足时间敏感的任务要求。==还建议提供工具来探索新的安全攻击及其在物联网中的解决方案，以验证NDN框架在不同类型的物联网网络中的适用性。</p><p>​<mark>区块链在物联网背景下的实施面临存储问题。需要大量的存储来存储区块链（Yang等人，2018a）。需要一个轻量级和集成的攻击检测以及预防机制来计算计算极限和存储容量，以满足时间敏感任务的要求。大量的行为被记录在区块链中，导致对通信网络的严重需求。现在使用比特币，数以百万计的交易会通过整个网络，耗费巨大的通信网络资源。因此，广播数以百万计的交易也是一个挑战。与用户知识类似，内容知识也包括在区块链中。使用内容知识也是一个开放的问题。</mark></p><p>​据了解，区块链框架能够提高NDN的性能。区块链可以用来改善不同的领域，如命名空间和路由。在区块链特性和NDN架构使用的激励下，有一些关于隐私的开放问题和关键挑战需要解决（Li等人，2019）。区块链技术被用作不同参与者的行为记录，所有参与者都可以访问。即使交易只涉及有效载荷的分割，用户行为的某些模式仍然可以通过统计方法或数据挖掘来消除。此外，利用大数据技术，区块链加密技术确认存在一些风险。交易地址的匿名性仍然不能保证用户的匿名性，一些故意的攻击会造成威胁。</p><p>6.2网络挑战</p><p>​Dledger的设计仍处于初始阶段。各种问题，如拒绝服务和同行串通，与系统的稳健性和安全性有关，已经被发现，需要研究人员的关注。签名是有效的；然而，存在着拒绝服务攻击的机会。恶意的对等人可能在账本系统中增加大量的区块，导致非法区块，从而破坏账本的数据完整性。</p><p>​此外，Dledger的设计也无法防止串通攻击。在串通攻击的情况下，对等人可以串通起来，帮助验证对方的无效区块，以便分类账系统可以接受这些区块。有必要对区块验证程序应用严格的安全规则（Zhang等人，2019a）。</p><p>​在支持NDN的基于区块链的物联网中，已经发现了不同的问题（Ahmad等人，2019）。</p><ul><li>车辆层面的认证可能与区块链层面的认证不同。这个论点本身对授权和访问控制都是有效的，因此需要一个授权和认证的一体化机制。</li><li>在基于区块链的NDN启用的物联网中，撤销不仅仅是身份的撤销。它也是关于特权和访问权的撤销。随着不同通信范式的多样化，撤销必须考虑被撤销者在这些类型的环境中的角色。这就需要为物联网建立一个可扩展的、强大的、高效的撤销机制。</li><li><mark>在基于NDN的区块链物联网中选择矿工的合适的公平机制是另一个开放的研究挑战。Minor的选择必须考虑所有的要求，如成本、可容忍的延迟和物联网应用的带宽。经济分析也是讨论物联网应用的投资回报率的一个基本要求。</mark></li><li>由于通信的瞬时性，物联网中的车辆互连时间是无法预测的。如果节点没有足够的时间保持联系，这将对区块链的共识机制产生不利的影响。因此，研究不断发展的区块链机制以确定资源受限环境的最佳机制非常重要。</li><li>PKI管理是物联网中的一个固有问题。考虑到它与区块链、NDN和物联网的整合，需要进行彻底的探索和分析，以获得这些技术的好处。需要一个高效的PKI机制，能够在异构和高度移动的物联网中有效工作。</li></ul><p>6.3其他领域的挑战</p><p>​BlockAuth框架能够处理不同的网络攻击，然而对这些攻击的抵抗水平分析还有待研究（Conti等人，2019b）。</p><p>​<mark>如何保证矿工之间的实时公平性也是一个重要的问题和挑战。当矿工创建一个区块时，它将沿着每个订阅的利益的反向路径被发送到NDN路由器旁边的其他矿工。这就造成了不公平，因为靠近生产者的矿工可能比其他矿工更早得到创建的区块。另一个问题是如何支持未成年人的动态变化。一个未成年人可能加入网络，或者一个现有的矿工可能离开网络。新矿工必须订阅现有矿工，而旧矿工必须从网络中删除（Guo等人，2019年）。</mark></p><p>​就安全和隐私问题而言，保护通信保密性和内容版权对于解决安全问题和挑战非常重要。内容的所有者必须在数据包或内容中提到所有的内容用户和隐私政策。对于这种情况，带有智能合约的区块链结构可能是最有希望的解决方案之一。内容所有者根据政策选择不同的智能合约，这些合约可以在执行行动时自动执行，以实现安全执行。基于区块链的分布式解决方案可用于执行内容名称的绑定，并保护用户和内容隐私（Khelifi等人，2018b）。</p><p>​事实证明，在NDN上实施区块链技术对世界非常有利。这个概念的应用和好处是独一无二的。NDN旨在完成区块链行业以前没有做过的事情，即在网络层取代TCP /IP（Nezvisky，2020）。这不仅对区块链社区有很多好处，而且对传统的在线应用也有好处。</p><p>​<mark>基于区块链的项目和框架被声称是去中心化的；然而，问题是，如果网络架构侧重于位置而不是数据，那么该服务是否是去中心化的。在目前的情况下，区块链包含网络交易中的节点。即使在所有节点上进行总账同步，一些数据包也是端对端发送到网络上的，这就造成了对一组特定节点的依赖。NDN上的区块链通过一个命名的数据网络协议解决了这个问题，它允许我们将焦点从服务器转移到数据上。与区块链项目不同，Blockchain over NDN在网络层面上保证了连接性。在NDN中，引入了数据驱动的真实性概念，以确保数据来源的安全性。</mark></p><p>​在基于NDN的区块链系统中，你可以为数据命名，包括用于加密数据的密钥。加密的签名可以保护每个数据包在网络中的传播。对于数据生产者来说，一旦数据被生产出来，NDN Link将创建一个对称密钥并使用策略密钥对它们进行编码。对于数据消费者来说，加密密钥可以从数据本身获得。<mark>通过在网络上分布数据，NDN减少了服务中断和网络成本。如果其中一方需要位于附近的数据，就没有必要向服务器请求，如果它在他们的范围内。网络内缓存允许数据被重复使用。通过NDN上的区块链，可以多次从路由器的缓冲区接收数据。通过路由器上的数据缓存，交易速度更快，数据包也不会丢失。</mark></p><p>​<mark>就安全和隐私问题而言，保护通信保密和内容版权对解决安全问题和挑战非常重要。内容的所有者必须在数据包或内容中提到所有的内容用户和隐私政策。对于这种情况，带有智能合约的区块链结构可能是最有希望的解决方案之一。内容所有者根据政策选择不同的智能合约，这些合约可以在执行行动时自动执行，以实现安全执行。基于区块链的分布式解决方案可用于执行内容名称的绑定，并保护用户和内容隐私（Khelifi等人，2018b）。</mark></p><p>7.结论</p><p>​区块链技术在NDN中的新兴理念正在迅速找到它的路径。区块链技术在IP上仍有一些严重的问题，如分层访问的效率不足。在NDN上使用区块链技术解决了这些问题，提供了一个去中心化的系统并简化了架构。本文概述了这一概念的想法以及专注于在NDN中使用区块链技术的研究。我们首先介绍了NDN的需求，并讨论了NDN架构。接下来，我们讨论了区块链架构和区块链技术在NDN中的使用。最后，我们提出了一些关于区块链技术在NDN上的关键挑战和问题。分析显示，随着每年出版物数量的增加，区块链技术在NDN中得到越来越多的关注。在应用领域方面，安全是最有趋势的领域，其次是物联网、网络、移动性和其他。总而言之，该调查报告显示，在NDN上寻找区块链技术仍处于初始阶段，从而促使NDN研究界为该主题作出专门努力。这篇调查报告将为有兴趣获得区块链技术在NDN上使用的想法和更好的理解的研究人员铺平道路。</p><h3 id="围绕研究问题进行相关研究成果列举注明参考文献"><a class="markdownIt-Anchor" href="#围绕研究问题进行相关研究成果列举注明参考文献"></a> 围绕研究问题，进行相关研究成果列举（注明参考文献）</h3><h3 id="研究现状总结及现有研究仍然存在不足或问题"><a class="markdownIt-Anchor" href="#研究现状总结及现有研究仍然存在不足或问题"></a> 研究现状总结，及现有研究仍然存在不足或问题</h3><h2 id="思路特色"><a class="markdownIt-Anchor" href="#思路特色"></a> 思路特色</h2><h3 id="与现有研究技术手段不同之处"><a class="markdownIt-Anchor" href="#与现有研究技术手段不同之处"></a> 与现有研究（技术手段）不同之处</h3><h2 id="关键问题技术点"><a class="markdownIt-Anchor" href="#关键问题技术点"></a> 关键问题/技术点</h2><h3 id="围绕研究题目提炼出需要解决的几个关键问题点技术点"><a class="markdownIt-Anchor" href="#围绕研究题目提炼出需要解决的几个关键问题点技术点"></a> 围绕研究题目，提炼出需要解决的几个关键问题点/技术点</h3><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><h3 id="总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"><a class="markdownIt-Anchor" href="#总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"></a> 总体解决方案（最好能画一个总体方案图、或有一段描述清楚总体思路）</h3><h3 id="每个问题点技术点分别的解决方案或模型设计"><a class="markdownIt-Anchor" href="#每个问题点技术点分别的解决方案或模型设计"></a> 每个问题点/技术点分别的解决方案或模型设计</h3><h2 id="实验设计结果分析"><a class="markdownIt-Anchor" href="#实验设计结果分析"></a> 实验设计&amp;结果分析</h2><h3 id="场景选择-实验设计-指标选取"><a class="markdownIt-Anchor" href="#场景选择-实验设计-指标选取"></a> 场景选择、实验设计、指标选取</h3><h3 id="实验结果分析"><a class="markdownIt-Anchor" href="#实验结果分析"></a> 实验结果分析</h3><h2 id="论文结论"><a class="markdownIt-Anchor" href="#论文结论"></a> 论文结论</h2><h3 id="得出文章结论"><a class="markdownIt-Anchor" href="#得出文章结论"></a> 得出文章结论</h3>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;NDN网络中的区块链技术：详细调查&lt;/p&gt; 
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;p&gt;​	随着大规模的新应用和在线服务的出现，互联网的未来设计将有新的要求和影响，如兼容移动性、可扩展性、可靠性和安全性。命名数据网络（NDN）是最有前途的未来互联网架构范式，它专注于内容驱动的通信。与传统的IP网络不同，基于内容的命名数据网络（NDN）&lt;mark&gt;可以快速检索和传输内容&lt;/mark&gt;。&lt;mark&gt;区块链技术已被广泛用于去中心化的支付、资产管理、医疗保健和云计算等&lt;/mark&gt;。区块链提供了一个去中心化的分布式解决方案，在不可靠的网络中保持一致和可靠的记录，而不需要中心化的权威。然而，==区块链技术在IP上仍有一些严重的问题，如缺乏分层访问的效率。在NDN上使用区块链技术解决了这些问题，提供了一个去中心化的系统并简化了架构。==在本文中，我们首次对区块链技术在NDN中的应用进行了详细而全面的调查。最后，还讨论了一些研究挑战和关键问题。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;/h2&gt;
&lt;h2 id=&quot;关键词&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关键词&quot;&gt;&lt;/a&gt; 关键词&lt;/h2&gt;
&lt;p&gt;NDN ，ICN ， Internet ，Named Data Networks ，Blockchain technology&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ip组播优缺点</title>
    <link href="http://example.com/2022/09/28/ip%E7%BB%84%E6%92%AD%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <id>http://example.com/2022/09/28/ip%E7%BB%84%E6%92%AD%E4%BC%98%E7%BC%BA%E7%82%B9/</id>
    <published>2022-09-28T01:45:54.000Z</published>
    <updated>2022-09-29T07:53:09.939Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <span id="more"></span><p>组播的优点：</p><ol><li>需要相同数据流的客户端加入相同的组共享一条数据流，节省了服务器的负载。具备广播所具备的优点。</li><li>由于组播协议是根据接受者的需要对数据流进行复制转发，所以服务端的服务总带宽不受客户接入端带宽的限制。IP协议允许有2亿6千多万个（268435456）组播，所以其提供的服务可以非常丰富。</li><li>此协议和单播协议一样允许在Internet宽带网上传输。</li></ol><p>组播的缺点：</p><p>1．与单播协议相比没有纠错机制，发生丢包错包后难以弥补，但可以通过一定的容错机制和QOS加以弥补。<br>2．现行网络虽然都支持组播的传输，但在客户认证、QOS等方面还需要完善，这些缺点在理论上都有成熟的解决方案，只是需要逐步推广应用到现存网络当中。</p><blockquote><p><a href="http://www.splaybow.com/post/zubo-youdian-quedian.html">组播的优点和缺点</a></p></blockquote><p>组播路由器在启动以后会向所有组播系 统组（224.0.0.1）IGMPv2发送常规的查询信息。 局域网内路由器收到查询信息后，会把该信息 的源 IP 地址和接收端口的 IP 地址进行比较， 并将有最低 IP 地址的路由器选举为 IGMP 的 唯一查询路由器。查询器按一定频率向组成员 发送成员关系查询消息，组成员发送报告消息 来应答查询；主机需要加入组播组时，将主动 发送报告消息；组成员在离开组播组时会发送 消息，查询器接受该消息并向该组播组发送消 息来查询并确定是否还有组成员。</p><p>组播路由协议</p><p>组播路由协议（Multicast routing protocol, MRP）利用分离映射机制将组播服务管理和组播数据转发分离，并完成后续的组播转发路径 的计算及维护等工作，解决了数据报文在路由 器之间转发的问题。域内组播路由协议分为密 集模式协议、稀疏模式协议。DVMRP，PIMDM，MOSPF 属于密集模式，CBT，PIM-SM 属于稀疏模式。目前域内主要使用 PIM-SM， PIM-DM，DVMRP 协议。<mark>域内协议的主要功 能是发现组播源并构建组播分发树，传递消息 到接收者；域间协议的主要功能是解决数据信 息如何在自治系统之间传递的问题。</mark></p><blockquote><p>[1]陈玲.IP组播协议概述及在网络通信中的应用[J].电子技术与软件工程,2018(21):33.</p></blockquote><p>由于以下原因，IP的多播无法得到有效的广泛部署：</p><ul><li>组播管理问题-IP组播标准没有为大规模商业部署提供许多重要的组播管理问题的解决方案，例如组管理，组播地址分配和对网络管理的支持[2]。</li><li>状态路由器-IP组播路由器需要 维护每个组的状态以进行数据包复制。此状态使路由器无法支持可扩展的多播组的数量。</li><li>缺乏更高级别功能的支持-IP多播基于尽力而为的数据传递，因此是不可靠的。 对于某些应用程序，例如多方游戏和软件分发，这是不希望的。</li></ul><p>作者：甸仔向前冲<br>链接：<a href="https://www.jianshu.com/p/40a2abfc18ba">https://www.jianshu.com/p/40a2abfc18ba</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>pbft使用ip multicast的缺点</title>
    <link href="http://example.com/2022/09/27/pbft%E4%BD%BF%E7%94%A8ip-multicast%E7%9A%84%E7%BC%BA%E7%82%B9/"/>
    <id>http://example.com/2022/09/27/pbft%E4%BD%BF%E7%94%A8ip-multicast%E7%9A%84%E7%BC%BA%E7%82%B9/</id>
    <published>2022-09-27T07:21:45.000Z</published>
    <updated>2022-09-28T01:46:13.337Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>聚合签名、门限签名和多签名</title>
    <link href="http://example.com/2022/09/27/%E8%81%9A%E5%90%88%E7%AD%BE%E5%90%8D%E3%80%81%E9%97%A8%E9%99%90%E7%AD%BE%E5%90%8D%E5%92%8C%E5%A4%9A%E7%AD%BE%E5%90%8D/"/>
    <id>http://example.com/2022/09/27/%E8%81%9A%E5%90%88%E7%AD%BE%E5%90%8D%E3%80%81%E9%97%A8%E9%99%90%E7%AD%BE%E5%90%8D%E5%92%8C%E5%A4%9A%E7%AD%BE%E5%90%8D/</id>
    <published>2022-09-27T02:25:22.000Z</published>
    <updated>2022-09-28T01:46:13.339Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <span id="more"></span><h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><p>数字签名在区块链技术中扮演着举足轻重的角色，因为每一笔交易都需要签名才能成为一笔有效的交易。准确地说，数字签名在区块链协议中有三方面的目标：</p><ol><li>证明所有权，并为花费资金提供授权</li><li>证明了不可否认性，意思是这个授权的证据是无法否认的</li><li>证明了被签名的交易没有被篡改，也无法被篡改（与签名不匹配会使交易失效）</li></ol><p>常见的签名方案中，单个用户为其消息生成签名；这就有一个潜在的风险：它构成了一个足以使该方案崩溃的单点故障，不法分子一旦获得了你的私钥，就可以拿走该私钥控制的所有资金。</p><p>上述问题可以通过引入多签名方案或者门限签名方案来避免。两类方案有一些相似之处：它们都是多方参与的协议，需要 n 个用户中至少 m 个参与签名，才能提供授权。不过，它们也有一些细微但重要的区别。这也正是正文的目的：概要地比较这两类签名方案的区别。</p><p>因为一些提案（比如 MuSig2 和 FROST），这个领域正在升温，正是介绍和比较三种技术的好时机：它们有同有异，常常让大家搞混。本文的目标是，尽可能少用技术术语，比较聚合签名、门限签名和多签名三类数字签名方案，并简要介绍 MuSig2 和 FROST。</p><h2 id="数字签名方案"><a class="markdownIt-Anchor" href="#数字签名方案"></a> 数字签名方案</h2><p>本节内容可能引发争议，因为它的目标之一是消除对多签名、门限签名和聚合签名的混淆，而这些概念在区块链的许多情境中可以合并和组合。</p><h3 id="多签名multisignatures"><a class="markdownIt-Anchor" href="#多签名multisignatures"></a> 多签名（Multisignatures）</h3><p>在简单的多签名方案中，n 名用户中的每一个都有独立的一对 公/私钥，而一个有效的签名，是 n 个用户的签名的集合。<mark>最终签名的验证需要用到每一个签名者的公钥。</mark></p><p>让每一个参与者都能持有自己的密钥对，使得基于多签名的授权证据占据多得多的空间。需要 n 个签名的设置不仅要在证据中包含 n 个签名，还要包含 n 个公钥。这使得多签名交易更昂贵，因为其体积和处理成本随 n 的增大而线性上升。</p><p>另一方面，用户有自己个人的密钥对，可以并行参与多个签名流程，这跟门限签名相反。在门限签名中，每一个参与者都只拥有一份密钥，可以签发 <em>一部分</em> 签名。这些签名碎片必须组合起来才能生成有效的最终签名。显然，这些密钥也许不能独立参加另一个签名流程。</p><p>参与多签名方案的密钥是存储在 <em>链上</em> 的，而在门限签名方案中，计算和密钥分割都是在 <em>链下</em> 完成的，只有一个公钥会存储在链上。这使得门限签名比多签名在体积和验证开销上更为便宜。</p><p><img src="https://res.btcstudy.org/btcstudy/images/aggregate-threshold-multisig-and-multisignatures/vM3zzMB_1kA" alt="img"></p><p>简单的多签名方案可能并不是区块链的最佳解决方案，因为其效率低下。为了解决这个问题，一些解决方案允许所有参与者用自己的私钥签名消息，然后这些签名会被组合成一个签名，并使用一把组合公钥来验证。这就是 MuSig2 及类似方案所用的机制，我们下文再叙。</p><p><img src="https://res.btcstudy.org/btcstudy/images/aggregate-threshold-multisig-and-multisignatures/6MDHG3pMWJY" alt="img"></p><h3 id="聚合签名aggregate-signatures"><a class="markdownIt-Anchor" href="#聚合签名aggregate-signatures"></a> 聚合签名（Aggregate signatures）</h3><p>在别的应用中，聚合签名被用于减少证书链条的体积，或者在路由协议中减少消息的体积。</p><p><mark>聚合签名是多签名（所有用户签名同一条消息）的重要一般化。聚合签名方案允许为 m 个不同签名者对 m 条不同消息的 m 个签名创建一条致密的签名。这就提供了更快的验证速度以及空间和带宽上的节省。</mark></p><p>签名聚合的机制主要有两种：一般化聚合、序列式聚合。现假设有一组 m 个用户，各有一对公私钥，而用户 i 想签名消息 Mi。</p><ol><li><mark>在一般化聚合方案中，（m 个用户中的）每个用户 i 都对自己的消息 Mi 创建签名 σi 。在创建 一个聚合签名时，任何人都可以运行公共聚合算法，将全部 m 个签名压缩成单个签名 σ。</mark></li><li><mark>在序列式签名聚合方案中，用户 1 签名 M1 来获得 σ1；用户组合 σ1 和 M2 来获得 σ2，以此类推。最终的签名是由用户 k 结合 Mk 和 σk-1 获得的。序列式签名聚合只能在签名流程中完成。</mark></li></ol><p><img src="https://res.btcstudy.org/btcstudy/images/aggregate-threshold-multisig-and-multisignatures/Zc_LyuBdDzp" alt="img"></p><p>许多签名方案都因为签名聚合技术而著称，比如 Schnorr 签名，基于格的签名（lattice-based）和基于配对的签名（pairing-based）。讲到基于配对的签名，我们要重点指出 BLS 方案（由 Boneh et al. 提出），已经被 <a href="https://medium.com/dfinity/the-internet-computer-for-geeks-a-new-dfinity-white-paper-ecb075b2d525">Dfinity</a> 和 <a href="https://www.algorand.com/technology/white-papers">Algorand</a> 等区块链实际使用。不过，这些协议签名的都是 <em>同一条消息</em>，可以应该把它们当作是多签名的案例，而不是聚合签名方案的合适案例。</p><p>最后，依然需要指出的是，大部分的这些方案都要求特定的签名顺序，但也有方案不再有这方面的要求（见 Lu et al. 的论文）。</p><p>聚合签名要能限制任何敌手在一个普通用户的签名上创建有效的聚合签名。</p><h3 id="门限签名threshold-signatures"><a class="markdownIt-Anchor" href="#门限签名threshold-signatures"></a> 门限签名（Threshold signatures）</h3><p>一个 m-n 的门限签名方案，指的是一组 n 个签名者中任意 m 个乃至更多的签名者即可代表整个群体、生成有效签名的数字签名方案。这个签名后面可以用一个 <em>群体公钥</em> 来验证，而这个群体公钥是由参与者个公钥组合而成的。一般来说，门限签名不会暴露参与生成签名的实际成员。</p><p><mark>门限签名方案的目标是控制签名能力（m &gt; 1），或者消除单点故障（n &gt; 1），又或者兼而有之。</mark></p><p>每一组签名者都可以由一个受信任的群主来管理，由群主来决定谁加入和离开群组。同一个群主可以管理多个群，反过来一个群也可以将群主完全分发给群成员，使得每一个成员都参与到所有的管理操作中。</p><p><mark>群 G 的 n 个成员中，任意 m 个成员构成的子集都可以生成出有效的签名。在创建签名时，每个成员都贡献一个签名碎片给特定的组合人，组合人会从这些签名碎片中推导出预想的门限签名。</mark></p><p><mark>任何人只要能获得群 G 的群体公钥，就可以验证门限签名。而大家指定的组合人既可以是一个真实的实体（比如受信任的群主），也可以是一个虚拟的实体，其操作以分布式的形式在所有群成员中计算。只要被指定的组合人可以在接受一个碎片签名作为门限签名的输入之前验证其有效性，这种门限签名方案就是健壮的。</mark></p><h3 id="比较"><a class="markdownIt-Anchor" href="#比较"></a> 比较</h3><p>迄今为止，我们已经讨论了四种非常相似的技术。下面是它们在几个维度上的比较：</p><table><thead><tr><th></th><th>私钥数量</th><th>所需消息数量</th><th>公开的公钥数量</th><th>所需签名者数量</th><th>公开的签名数量</th></tr></thead><tbody><tr><td>简单多签名</td><td>n</td><td>1</td><td>n</td><td>n</td><td>n</td></tr><tr><td>多签名</td><td>n</td><td>1</td><td>1</td><td>n</td><td>1</td></tr><tr><td>聚合签名</td><td>n</td><td>1*</td><td>1</td><td>n</td><td>1</td></tr><tr><td>门限签名**</td><td>n</td><td>1</td><td>1</td><td>m &lt; n</td><td>1</td></tr></tbody></table><p>（*）在此案例中，消息可以是完全不同的，最多可以有 n 条不同的消息</p><p>（**）假设是 m-n 的门限方案</p><h2 id="介绍-musig2-和-frost"><a class="markdownIt-Anchor" href="#介绍-musig2-和-frost"></a> 介绍 MuSig2 和 FROST</h2><p>MuSig2 和 FROST 是一众为区块链平台引入多签名或门限签名的提议之二。本节打算对两者作一个简单的、非技术性的介绍。对它们的细节和数学原理有兴趣的，可以阅读 Nick et al. 和 Komlo and Goldberg 。</p><h3 id="简要介绍-musig2"><a class="markdownIt-Anchor" href="#简要介绍-musig2"></a> 简要介绍 MuSig2</h3><p>MuSig2（Nick et al.）不能被视为一种见到的多签名方案，因为它跟聚合签名方案有一些相似之处。</p><p>MuSig2 的亮点有：</p><ul><li>可以安全地并行签名</li><li>可以聚合密钥</li><li>产生的输出是常规的 Schnorr 签名</li><li>将通信轮次减少到了两轮，而更早的协议 MuSig 需要进行三轮通信</li><li>签名者面对的复杂性与普通的 Schnorr 签名相似</li></ul><p>在 MuSig2 中，每个参与者都有一对公私钥。它们是使用随机数 <em>x</em> ∈ ℤ （私钥）计算 X = g ^ x （公钥）来生成的（g 是一个循环群 G 上的生成点）。</p><p>这个方案使用两轮通信来让 m 个用户生成 m 个中间签名，这些签名结合在一起生成一个最终的签名。</p><p>这个签名使用这些用户的公钥所结合生成的一把公钥来验证。</p><p>在使用这种方案来为区块链交易授权时，最终保留在链上的只有一把公钥和一个签名，因此其成本远低于多签名、等同于使用门限签名机制所生成的签名。进一步地，MuSig2 中的密钥生成比门限签名中的密钥生成要简单。与任何门限签名方案相比，MuSig2 的主要缺点在于，它需要 m 个签名者参与（m = n），所以 MuSig2 也成了一个死板的解决方案。</p><h3 id="将多签名转为门限签名"><a class="markdownIt-Anchor" href="#将多签名转为门限签名"></a> 将多签名转为门限签名</h3><p>要让一种多签名方案更加灵活，一种可行的解决方案是修改算法，将之转为一种门限签名方案。这一方向需要定义一种默克尔树来包含所有可能的签名者组合的密钥。这棵默克尔树将允许我们靠遍历来检查一组签名者是不是有效的签名群组。</p><p><img src="https://res.btcstudy.org/btcstudy/images/aggregate-threshold-multisig-and-multisignatures/lbEMSaAzrxA" alt="img"></p><p>设 n 为参与者的数量，而 m 为阈值。则上述的默克尔树需要包含的元素数量为 <em>C(n,m)</em> 。这棵树的空间复杂性 <em>O(n^(n-m))</em> 将与阈值呈指数关系，这也很直接能推理出来：阈值 m 越小，<em>C(n,m)</em> 越大。</p><p>在一棵默克尔树上搜索、遍历、插入和删除元素的时间复杂度 <em>O(log(C(n, m))) &lt; O(log(n^m)) =O(m · log(n))</em> 。</p><p>使用默克尔树来存储所有可能的签名群组的想法，可以跟 MuSig2、BLS 以及任何多签名方案相结合。这个特性在比特币的 <a href="https://medium.com/iovlabs-innovation-stories/taproot-and-rsk-6fc8a3f8ccaf">Taproot</a> 升级中以 <a href="https://bitcoinops.org/en/topics/mast/">MAST</a>（merkelized abstract syntax trees）为名，它使用默克尔树来存储多个用户指定的、为花费该笔比特币需要满足的充分条件。</p><h3 id="frost-简介"><a class="markdownIt-Anchor" href="#frost-简介"></a> FROST 简介</h3><p>FROST 门限签名（Komlo and Goldberg）使用一种准受信任的签名聚合者（SA）设置，该设置的存在可以减少带宽开销。聚合者是为协作而设置的，并没有信息上的特权。SA 既可以是协议的一个参与者，也可以是一个外部的第三方。SA 要负责识别行为不轨的参与者，并在协议完成时发布群体的签名。即使 SA 自身行为不轨，协议也可对抗适应型<a href="https://en.wikipedia.org/wiki/Adaptive_chosen-ciphertext_attack">选择性明文攻击</a>。恶意的 SA 有能力发起分布式拒绝服务攻击，也可坏人先告状，但无法获得参与者的私钥，也无法使不合适的信息得到签署。</p><p>FROST 里的密钥生成需要两轮通信，并依赖于 Pedersen 的分布式密钥生成算法，不过签名算法是基于累加型密钥分割（additive secret sharing）的。</p><p>此外，签名操作利用绑定技术来避免伪造攻击。签名流程由两部分组成：一个预处理阶段和一个单轮的签名阶段；但也可以把两个阶段合而为一。</p><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>我们研究的不同技术各有优缺点。简单的多签名方案因为需要验证多个不同的签名，可以认为是低效的。不过，他是最简单的解决方案，而且在参与者数量不多时，它也可以是有趣的选择。</p><p>具备聚合特性的多签名方案，比如 MuSig2 和 BLS，克服了上述的效率缺陷，所以在参与者数量增加时，它们是可以考虑的解决方案。不过，严格来说，多签名（不论是简单的还是聚合的）还是有一些死板，因为它需要所有参与者都参与到一个操作中。</p><p>一个更灵活的解决方案是门限签名，既有基于分布式密钥生成的实现方案（比如 FROST），也有 Stinson and Strobl 提出的提案，还可以将包含了所有可能签名者集合的默克尔树根任意的多签名方案（比如 MuSig2 和 BLS）相结合。</p><h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2><ol><li>Boneh, Dan, et al. “Aggregate and Verifiably Encrypted Signatures from Bilinear Maps.” Lecture Notes in Computer Science, vol. 2656, Springer, 2003, pp. 416–432. SpringerLink, <a href="https://link.springer.com/chapter/10.1007/3-540-39200-9_26">https://link.springer.com/chapter/10.1007/3-540-39200-9_26</a>.</li><li>Komlo, Chelsea, and Ian Goldberg. “FROST: Flexible Round-Optimized Schnorr Threshold Signatures.” Lecture Notes in Computer Science, vol. 12804, Springer, 2021, pp. 34–65. SpringerLink, <a href="https://link.springer.com/chapter/10.1007/978-3-030-81652-0_2">https://link.springer.com/chapter/10.1007/978-3-030-81652-0_2</a>.</li><li>Lu, Xiuhua, et al. “A Lattice-Based Unordered Aggregate Signature Scheme Based on the Intersection Method.” IEEE Access, vol. 6, 2018, pp. 33986–33994. IEEE Xplore, <a href="https://ieeexplore.ieee.org/document/8386429">https://ieeexplore.ieee.org/document/8386429</a>.</li><li>Nick, Jonas, et al. “MuSig2: Simple Two-Round Schnorr Multi-signatures.” Lecture Notes in Computer Science, vol. 12825, Springer, 2021, pp. 189–221. SpringerLink, <a href="https://link.springer.com/chapter/10.1007/978-3-030-84242-0_8">https://link.springer.com/chapter/10.1007/978-3-030-84242-0_8</a>.</li><li>Stinson, Douglas R., and Reto Strobl. “Provably Secure Distributed Schnorr Signatures and a (t, n) Threshold Scheme for Implicit Certificates.” Lecture Notes in Computer Science, vol. 2119, Springer, 2001, pp. 417–434. SpringerLink, <a href="https://link.springer.com/chapter/10.1007/3-540-47719-5_33">https://link.springer.com/chapter/10.1007/3-540-47719-5_33</a>.</li></ol>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>HotStuff：BFT Consensus in the Lens of Blockchain</title>
    <link href="http://example.com/2022/09/26/HotStuff%EF%BC%9ABFT-Consensus-in-the-Lens-of-Blockchain/"/>
    <id>http://example.com/2022/09/26/HotStuff%EF%BC%9ABFT-Consensus-in-the-Lens-of-Blockchain/</id>
    <published>2022-09-26T02:14:15.000Z</published>
    <updated>2022-10-20T07:38:48.386Z</updated>
    
    <content type="html"><![CDATA[<p align="right">透过区块链看拜占庭容错共识</p> <h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>​我们提出了HotStuff，一个基于leader节点的拜占庭问题(Byzantine fault-tolerant replication protocal， BFT)的部分同步(partially synchronous)模型。一旦网络进入同步状态，HotStuff算法将允许一个正确的leader节点以实际（相对于最大）网络延迟的频率（速度）推动协议达成共识依照某个频率（如最大网络延迟）发起共识，这一特性被称为响应性（responsiveness），并且<mark>通信复杂度与复制(replica)数量呈线性关系</mark>。据我们所知，HotStuff是第一个表现出这些综合特性的部分同步BFT复制协议。HotStuff是围绕着一个新颖的框架建立的，它在经典的BFT基础和区块链之间形成了一个桥梁。它允许其他已知的协议（DLS、PBFT、Tendermint、Casper）和我们的协议在一个共同的框架中表达。</p><p>​我们在一个有100多个副本的网络上部署HotStuff，实现了与BFT-MaRt相当的吞吐量和延迟，同时在leader故障切换期间拥有线性的网络通信次数（与之相对的，BFTSMaRt算法相同的功能需要使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>次网络通信）。</p><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>​拜占庭容错(Byzantine fault tolerance, BFT)指的是一个计算网络在其副本节点遭遇任意错误（如拜占庭错误）时，如何保证关键的网络操作能够得以执行。在状态机复制（SMR）的背景下[35, 47]，整个系统提供了一个可复制的服务，该服务可以被镜像部署到网络的N个副本中。一个BFT-SMR协议用来保证没有出错的副本能够以统一的顺序执行一系列由客户端提交的指令，即使存在一些拜占庭节点尝试阻止网络达成共识。在一轮共识中，算法保证由n-f个未出错的副本能够独立的执行客户端指令，并产生该指令下相同且唯一的结果。正如常见的那样，我们在这里关注的是部分同步通信模型（Partially Synchronous Communication Model）[25]，即在某个未知的全局稳定时间（Global Stabilazation TimeGST）之后，信息传输的已知约束∆成立。在这个模型中，需要n≥3f+1的非故障复制体以相同的顺序对相同的命令达成一致（例如，[12]），并且只有在GST之后才能确定性地确保进展[27]。</p><p>​==当BFT SMR协议最初被构想出来时，典型的目标系统规模是n=4或n=7，部署在局域网上。然而，由于拜占庭容错在区块链中的应用，人们对其重新产生了兴趣，现在需要能够扩展到更大n的解决方案。==与无权限区块链（例如支持比特币的区块链）相比，所谓的有权限区块链涉及一组复制体，它们共同维护一个有序的命令分类账，或者说，这些副本支持了网络的SMR特性。<mark>尽管它们具有许可的性质，但设想了数百甚至数千个复制体的数量（例如，[42，30]）。此外，将它们部署到广域网络需要设置∆以适应更高的通信延迟变化。</mark></p><p>​**拓展性挑战（The scaling challenge）。**自从PBFT[20]（部分同步模型中第一个实用的BFT复制解决方案）问世以来，许多BFT解决方案都是围绕其核心的两阶段范式建立的。其实用性在于，一个稳定的leader节点可以在短短两轮的消息交换中驱动一个共识决定。<mark>第一阶段通过让一个副本获得包含 n−f 个投票的法定人数证书(Quorum Certificate, QC)，进而保证提议的唯一性。第二阶段则保证leader节点可以说服其他副本去向一个安全的提议投票。</mark></p><p>​为新的leader节点收集信息以及向副本发送提案的过程，称之为视图转换(view change)，是整个网络的核心操作。<mark>不幸的是，基于两阶段范式的视图改变远不是那么简单[38]，容易出错[4]，甚至对于中等规模的系统也会产生巨大的通信费用。</mark></p><p>它要求新的leader从(n - f)个副本中传递信息，每个副本报告自己的最高已知QC。即使只计算认证器（数字签名或消息认证码），在PBFT中，传达一个新提案的通信次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>个认证器，==该算法的一个变体，通过阈值数字签名(Threshold Digital Signatures)，将多个认证器组合成一个的算法能有效优化耗时，不过即便如此依旧有 O(n2) 的时间复杂度。（例如[18, 30]）==在PBFT中，如果在达成单一共识决定之前，发生<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>个视图变化，那么传输的认证器总数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n^3*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>)，即使有阈值签名也是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。这一扩展挑战不仅困扰着PBFT，也困扰着此后开发的许多其他协议，<mark>例如Prime[9]、Zyzzyva[34]、Upright[22]、BFT-MaRt[13]、700BFT[11]和SBFT[30]</mark>。</p><p>​<mark>HotStuff围绕着一个三阶段的核心，允许新leader简单地挑选它所知道的最高QC。它引入了第二个阶段，允许复制体在该阶段投票后 “改变主意”，根本不需要leader证明。因此同时降低了时间复杂度以及换leader协议的复杂度。最后，在几乎完成所有阶段的共识后，HotStuff能够很简单的并行化，以保证便捷的leader循环。</mark></p><p>​据我们所知，在区块链领域只有如Tendermint[15, 16]和Casper[17]这样的BFT协议，遵循这样一个简单的leader制度。然而，这些系统是围绕<mark>同步核心</mark>建立的，其中提案是在预先确定的时间间隔内提出的，必须适应在广域点对点gossip网络上传播信息所需的最坏情况。这样做，他们放弃了大多数实用的BFT-SMR解决方案（包括上面列出的那些）的一个标志，即乐观的响应性[42]。非正式地，响应性要求非故障leader一旦被指定，就能在仅取决于实际消息延迟的时间内推动协议达成共识，与任何已知的消息传输延迟的上限无关[10]。==对我们的模型来说，更合适的是乐观的响应性，它只要求在特殊的（希望是常见的）情况下–这里是在达成GST之后–有响应性。==无论乐观与否，<mark>像Tendermint/Casper这样的设计是不可能有响应性的</mark>。<mark>问题的关键在于，可能存在一个具有最高质量控制的诚实的副本，但leader并不知道它。我们可以建立这样的场景，使进展卡死</mark>（详细的无生境场景见第4.4节）。==事实上，如果不能在关键的协议步骤中加入必要的延迟，就会导致完全失去有效性，这在一些现有的部署中已经有所报道，==例如，见[3, 2, 19] 。</p><p>​**我们的贡献。**据我们所知，我们提出了第一个BFT-SMR协议，称为HotStuff，以实现以下两个特性。</p><p>​<strong>线性视图变换复杂度</strong>:在达到GST时限之后，任何正确的leader一旦被指定，只需发送O(n)个副本认证,就可以提出一个公式决策。这包括leader被替换的情况。因此，在大量leader崩溃的最坏情况下，GST之后达成共识的通信成本是O(n2)个认证者。</p><p>​**乐观的回应性。**在达到GST时限之后，任何正确的leader，一旦被指定，只需要等待前n-f个回应，以保证它能创造一个能取得进展的提案。这包括leader被替换的情况。</p><p>​<mark>HotStuff的另一个特点是，新的leader推动协议达成共识的成本不高于当前leader节点人的成本。因此，HotStuff支持leader的频繁继任，有人认为这在区块链背景下对确保链的质量很有用[28]。</mark></p><p>​==HotStuff通过在每个视图中增加一个阶段来实现这些特性，这是以延迟的小代价换取leader替换协议的大大简化。==这种交换只产生了实际的网络延迟，在实践中通常远远小于∆。因此，我们希望这种增加的延迟比以前的协议所产生的延迟要小得多，这些协议放弃了响应性以实现线性的视图更换。此外，由于我们在第5节中介绍的有效管道，吞吐量也不会受到影响。</p><p>​除了理论上的贡献，HotStuff还提供了对一般BFT复制的理解和实践中的协议实例化的见解（见第6节）。</p><ul><li><p>一个运行在图上的BFT复现框架。 通过投票和规则提交保障的安全性。 活跃性是通过Pacemaker提供的，支持向图添加新的副本。</p></li><li><p>在该框架下实现已知协议（DLS、PBFT、Tendmint和Casper），以及我们自己的HotStuff协议。</p><p>HotStuff的另一个优点是非常简单，由于其机制本身就是非常经济性的：只包含两种消息的类别，以及一个简单地规则用于决定副本相互之间如何对待。安全性是通过投票和提交规则来保证的，而活跃性则需要<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/chimeiwangliang/p/7975911.html">Pacemaker机制</a>，该机制与安全机制是完全独立的。同时，他允许通过少量的变化实现几种已知的协议(DLS, PBDF, Tendermint和Casper)。这种灵活性来源于其对于图上节点的操作，在现代区块链和传统的BFT基础间架设了一个桥梁。</p></li></ul><p>​我们描述了HotStuff的原型实现和初步评估。在一个有一百多个副本的网络上部署，HotStuff实现了与BFT-MaRt等成熟系统相当的吞吐量和延迟，有时甚至超过了BFT-MaRt，其代码复杂度远远超过了HotStuff。我们进一步证明，HotStuff的通信足迹在面对频繁的leader更换时保持不变，而BFT-MaRt则随着复制数量的增加而呈二次方增长。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210140901336.png" alt="image-20221014090155168"></p><p><a href="https://zhuanlan.zhihu.com/p/137667542">区块链HotStuff共识协议论文翻译-Introduction</a></p><h2 id="2相关工作"><a class="markdownIt-Anchor" href="#2相关工作"></a> 2.相关工作</h2><h2 id="markdown-增加文献引用"><a class="markdownIt-Anchor" href="#markdown-增加文献引用"></a> Markdown 增加文献引用</h2><p>​Lamport等人[37]将面对拜占庭失败时达成共识的问题表述为拜占庭将军问题，他们还创造了 "拜占庭失败 "一词。第一个同步解决方案是由Pease等人[43]给出的，后来由Dolev和Strong[24]改进。改进后的协议具有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的通信复杂度，Dolev和Reischuk[23]证明这是最佳的。Katz和Koo[32]给出了一个使用随机性的基于leader的同步协议，显示了一个具有(n - 1)/2弹性的预期恒定回合解决方案。</p><p>​同时，在异步设置中，Fischer等人[27]表明，在异步设置中，面对单个故障，该问题是无法确定解决的。此外，Ben-Or[12]证明了任何异步解决方案的（n - 1）/3弹性约束。设计了两种方法来规避这种不可能性。一个是由Ben[12]提出的基于随机化的做法，使用持续随机的“虚拟硬币”翻转，直到恰好收敛到共识状态。后续的工作使用加密方法来共享一个不可预测的“硬币”，将复杂度降低到可预期的恒定回合，以及复杂度 O(n3) 的通信开销[18]。</p><p>​第二种方法依赖于部分同步，最早由Dwork, Lynch, and Stockmeyer (DLS) [25]展示。该协议在异步期间保持安全，而在系统变得同步之后，DLS保证终止。一旦保持同步，DLS就会产生O(n4)的总通信量和O(n)的每个决策回合。</p><p>​状态机复制的核心是依靠共识来安排客户请求的顺序，以便正确的复制体按照这个顺序执行它们。在SMR中反复出现的对共识的需求导致Lamport设计了Paxos[36]，这是一个运行古老管道的协议，其中一个稳定的leader以线性通信和一次往返的方式驱动决策。类似的重点促使Castro和Liskov[20, 21]开发了一个名为PBFT的基于leader的拜占庭SMR协议，其稳定的leader需要O(n2)次通信和每次决策的两次往返，而leader替换协议产生了O(n3)次通信。PBFT已经被部署在几个系统中，包括BFTSMaRt[13]。Kotla等人在名为Zyzzyva[34]的协议中为PBFT引入了一条乐观的线性路径，该协议被用于几个系统中，例如Upright[22]和Byzcoin[33]。乐观的路径具有线性复杂度，而leader替换协议仍然是O（n3）。Abraham等人[4]后来在Zyzzyva中暴露了一个安全漏洞，并提出了xes[5，30]。另一方面，为了同时降低协议本身的复杂性，Song等人提出了Bosco[49]，这是一个简单的单步协议，在乐观路径上具有低延迟，需要5f+1个副本。SBFT[30]引入了一个O(n2)的通信视图改变协议，支持一个稳定的leader协议，具有乐观的线性，一个往返的决定。它通过利用两种方法降低了通信复杂性：Reiter[45]的基于收集器的通信范式，以及Cachin等人[18]通过协议投票的阈值加密法进行签名组合。</p><p>​状态复制机(SMR)通过其核心的共识机制对客户端请求进行排序，以达到确定性的执行结果。这种SMR反复出现的需求，让Lamport设计出了Paxos协议[36]，该协议提供了一个高效的流水线，在这个流水线上，一个稳定的leader节点可以在一轮通信中，使用线性的通信开销来广播决策。Castro和Liskov[20, 21]也实现了相似的需求，他们提供了一个高效的基于leader节点的拜占庭SMR协议，该协议名字叫做PBFT。在PBFT中，一个稳定的leader节点需要 O(n2) 的通信开销和两轮通信来完成一次决策广播，同时，倘若leader节点需要更替，则需要花费 O(n3) 的通信开销。PBFT被部署在了多个系统中，其中就包括<mark>BFTSMaRt[13]</mark>。Kotla等研究者则在PBFT基础上，引入了一个乐观的线性路径(optimistic linear path)，并得到了Zyzzyva协议[34]，该协议也被部署在了Upright、Byzcoin等系统中。乐观路径拥有线性的复杂度，但leader节点的更替仍然需要 O(n3) 的时间复杂度。Abraham等人随机表示Zyzzyva协议存在安全漏洞，并提交了修正方案。改修正方案还有效地减小了协议自身的复杂度。Song等人提出了Bosco协议，这是一个建议的单阶段协议，在乐观路径上拥有较低的延迟。该协议要求 5f+1 个副本节点。SBFT协议引入了一个能够在 O(n2) 通信复杂度下，实现view-change的协议，并且支持一个稳定的leader节点实现乐观的线性、单轮决策。协议利用两种方法来降低通信复杂度，Reiter提出的一个机遇收集者(collector)的通信机制，以及Cachin等人提出的通过门限密码(threshold crptography)对协议投票以实现部分签名合并的算法。</p><p>​Ramasamy等人提出了一个采用随机化的基于leader节点的拜占庭SMR协议[44]，<mark>Miller等人开发了一个名为HoneyBadgerBFT的无leader节点变体[39]。这些随机拜占庭解决方案的核心是采用随机异步拜占庭共识，其最好的已知通信复杂度为O(n3)（见上文），通过分批摊销成本。然而，最近，基于这篇HotStuff论文中的想法，向PODC’19[8]提交的一份并行文件进一步将通信复杂度提高到O(n2)。</mark></p><p>​比特币的核心是一个被称为中本聪的协议[40]，这是一个同步协议，只有概率性的安全保证，没有真实性（见[28，41，6]中的分析）。它在参与者未知的无许可模式下运行，并通过工作证明保持弹性。如上所述，最近的区块链解决方案以各种方式将工作证明解决方案与经典的BFT解决方案混合起来[26, 33, 7, 17, 29, 31, 42]。这些混合的解决方案中，都需要解决轮流领导的问题，这为HotStuff提供了设计动机。</p><h2 id="3模型"><a class="markdownIt-Anchor" href="#3模型"></a> 3.模型</h2><p>​我们考虑一个由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn><mi>f</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=3f+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个副本组成的系统，以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i∈[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>为索引，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi></mrow></mrow><annotation encoding="application/x-tex">[n]={1, . . . , n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span></span>. 一组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>⊂</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">F⊂[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>的最多<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>F</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">f = |F|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord">∣</span></span></span></span>的复制是拜占庭式的故障，其余的是正确的。我们通常会把拜占庭副本称为由对手协调，对手会了解这些副本所持有的所有内部状态（包括它们的加密密钥，见下文）。</p><p>​网络通信是点对点的、经过验证的和可靠的：一个正确的复制体从另一个正确的复制体收到一个消息，当且仅当后者向前者发送该消息。当我们提到 "广播 "时，它涉及到广播者，如果正确的话，向所有副本，包括它自己，发送相同的点对点信息。我们采用Dwork等人[25]的部分同步模型，其中有一个已知的边界<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span>和一个未知的全球稳定时间（GST），这样在GST之后，两个正确的副本之间的所有传输都在时间∆内到达。我们的协议将始终确保安全，并将保证在GST之后的一定时间内取得进展。(在GST之前保证进度是不可能的[27]。)在实践中，如果系统在GST之后足够长的时间内保持稳定（即，如果消息在∆时间内到达），我们的协议将保证进度，尽管假设它永远这样做是为了简化讨论。</p><p>​密码学原理。HotStuff使用了阈值签名[48, 18, 14]。在一个(k, n)阈值签名方案中，有一个由所有副本持有的单一公钥，而n个副本中的每一个都持有一个不同的私钥。第i个副本可以使用其私钥对消息m贡献一个部分签名<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ρ</mi><mi>i</mi></msub><mo>←</mo><msub><mi mathvariant="normal">tsign</mi><mo>⁡</mo><mi>i</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\rho_i \leftarrow \operatorname{tsign}_i(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">t</span><span class="mord mathrm">s</span><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mord mathrm">n</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.21752399999999997em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>。部分签名<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow><mo fence="true">{</mo><msub><mi>ρ</mi><mi>i</mi></msub><mo fence="true">}</mo></mrow><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\left\{\rho_i\right\}_{i \in I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.07707em;vertical-align:-0.32706999999999997em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathdefault">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17863099999999998em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32706999999999997em;"><span></span></span></span></span></span></span></span></span></span> ，其中|I| = k，每个ρi ← tsigni(m)，可以用来对m产生数字签名σ← tcombine(m, {ρi}i∈I )，任何其他副本可以使用公钥和函数tverify验证该签名。我们要求，如果ρi ← tsigni(m)对于每个i∈I，|I| = k，并且如果σ← tcombine(m, {ρi}i∈I )，那么tverify(m, σ)返回真。然而，考虑到对神谕{tsigni(-)}i∈[n]/F的访问，对手在严格少于k-f的这些神谕上查询tsigni(m)，产生消息m的签名σ的概率可以忽略不计（即，使tverify(m, σ)返回真）。在本文中，我们使用k=2f+1的阈值。同样，我们通常会在协议描述中隐含对tverify的调用。</p><p>​我们还需要一个加密哈希函数h（也称为消息摘要函数），它将一个任意长度的输入映射到一个固定长度的输出。哈希函数必须是抗碰撞的[46]，这非正式地要求对手产生h(m)=h(m′)的输入m和m′的概率是可以忽略的。因此，h(m)可以作为协议中唯一输入m的识别器。</p><p><strong>复杂度测量。</strong> 我们关心的复杂度是认证器复杂度，具体来说就是在所有副本i∈[n]上，副本i在GST后达成共识决定的协议中收到的认证器数量之和。(同样，在GST之前，在最坏的情况下可能根本无法达成共识决定[27]）。这里，一个认证器是一个部分签名或一个签名。认证器复杂度是通信复杂度的一个有用的衡量标准，原因有几个。首先，像比特复杂度，也不像消息复杂度，它隐藏了关于传输拓扑结构的不必要的细节。例如，携带一个认证器的n个消息与携带n个认证器的一个消息计数相同。第二，认证器复杂度比比特复杂度更适合捕捉像我们这样反复达成共识的协议中的成本，其中每个共识决定（或在通往该共识决定的路上提出的每个观点）都由一个单调增加的计数器识别。也就是说，因为这样的计数器是无限增加的，所以发送这样的计数器的协议的位复杂度是不能被约束的。第三，由于在实践中，产生或验证数字签名的加密操作以及产生或结合部分签名的加密操作通常是使用它们的协议中计算最密集的操作，认证器的复杂性也提供了对协议计算负担的洞察力。</p><ol start="4"><li>基本hotstuff</li></ol><p>HotStuff解决了状态机复制（SMR）问题。SMR的核心是一个决定客户不断增长的命令请求日志的协议。一组状态机复制体按照顺序一致地应用命令。客户端向所有的复制体发送命令请求，并等待其中（f+1）个复制体的回应。在大多数情况下，我们在讨论中省略了客户端，并将有关客户端请求的编号和去重的问题交给标准文献。</p><p>​基本HotStuff解决方案在算法2中提出。该协议在一个连续的视图中工作，其编号为单调增加的视图编号。每个viewNumber都有一个唯一的专用leader节点，为所有人所知。每个副本都将一棵悬而未决的命令树作为其本地数据结构。每个树节点都包含一个提议的命令（或一批），与协议相关的元数据，以及一个父级链接。一个给定节点所带领的分支是通过访问父链接从该节点一直到树根的路径。在协议期间，一个单调增长的分支成为承诺。为了成为承诺，提出分支的特定视图的leader必须在准备、预承诺和承诺三个阶段从（n - f ）个副本的法定人数中收集投票。</p><p>​该协议的一个关键成分是对leader提案的(n - f )票数的集合，被称为法定人数证书（简称 “QC”）。QC与一个特定的节点和一个视图编号相关联。tcombine工具采用了一个阈值签名方案，以产生一个(n - f )签名的投票表示，作为一个单一的认证器。</p><p>​下面我们将分阶段对协议逻辑进行操作性描述，然后在算法2中进行精确的规范，并以安全性、有效性和复杂性的论证来结束本节。</p><h3 id="41阶段"><a class="markdownIt-Anchor" href="#41阶段"></a> 4.1阶段</h3><p>​准备阶段。新leader的协议从收集（n - f ）个副本的新视图消息开始。新视图消息由一个副本在过渡到viewNumber（包括第一个视图）时发送，并携带该副本收到的最高prepareQC（如果没有，则为⊥），如下所述。</p><p>​leader节点对这些消息进行处理，以选择一个分支，该分支具有形成prepareQC的最高前视图。leader节点在新视图信息中选择具有最高视图的prepareQC，表示为highQC。因为highQC是(n - f )个副本中最高的，没有更高的视图可以达成提交决定。因此，由highQC.nodeleader节点的分支是安全的。</p><p>​在职leader可以省略收集新视点信息来选择安全分支，他可以简单地选择自己的最高prepareQC作为highQC。我们将这一优化推迟到第6节，在这一节中只描述一个单一的、不结盟的leader协议。请注意，与类似PBFT的协议不同，在leader协议中包括这一步骤是直接的，而且无论在什么情况下，它都会产生与协议中所有其他阶段相同的线性开销。</p><p>​leader节点使用createLeaf方法用一个新的提议来扩展highQC.node的尾部。该方法创建一个新的叶子节点作为子节点，并将父节点的摘要嵌入子节点中。然后，leader在准备消息中向所有其他副本发送新节点。为了安全起见，该提议带有高QC。</p><p>​在收到leader发出的当前视图的准备消息后，副本r使用安全节点谓词来决定是否接受它。如果它被接受，复制体就向leader发送一个带有部分签名（由tsignr产生）的提案的准备投票。</p><p>​<strong>safeNode谓词</strong>。safeNode谓词是该协议的一个核心要素。它检查携带QC论证m.justify的提议消息m，并确定m.node是否可以安全接受。接受提议的安全规则是m.node的分支从当前锁定的节点延伸到锁定的QC.node。另一方面，有效性规则是，如果m.justify的视图高于当前锁定的QC .node，复制体将接受m。只要两个规则中的任何一个成立，该谓词就是真的。</p><p>​<strong>预承诺阶段</strong>。当leader收到针对当前提案curProposal的(n - f )张准备票时，它将其合并为prepareQC。leader节点在预承诺消息中广播prepareQC。一个副本以预承诺投票的方式回应leader，该预承诺投票具有提案的签名摘要。</p><p>​<strong>提交阶段</strong>。提交阶段与预提交阶段类似。当leader收到(n - f )张预提交投票时，它将这些投票合并成一个precommitQC，并在提交消息中进行广播；复制体以提交投票来回应它。重要的是，在这一点上，一个复制体通过将其锁定的QC设置为precommitQC而被锁定（算法2的第25行）。这对保护提案的安全至关重要，因为它可能成为一个共识决定。</p><p>**决定阶段。**当leader收到(n - f )张提交票时，它将它们合并成一个commitQC。一旦leader集合了一个commitQC，它就会将其作为一个decide消息发送给所有其他的副本。收到决定消息后，复制体认为commitQC中包含的提议是一个承诺的决定，并执行承诺分支中的命令。复制体增加viewNumber并开始下一个视图。</p><p>**nextView的中断。**在所有阶段，副本在视图viewNumber处等待消息，等待的时间由辅助的nextView(viewNumber )工具决定。如果nextView(viewNumber )中断等待，副本也会增加viewNumber并开始下一个视图。</p><h3 id="42数据结构"><a class="markdownIt-Anchor" href="#42数据结构"></a> 4.2数据结构</h3><p>**信息。**协议中的消息m有一组固定的elds，使用算法1中的Msg()工具进行填充。m自动带有curView，即发送者的当前视图编号。每个消息都有一个m.type∈ {new-view, prepare, pre-commit, commit, decide}。m.node包含一个提议节点（提议分支的叶子节点）。有一个可选的eld m.justify。leader节点总是使用这个字段来携带不同阶段的QC。复制体在new-view消息中使用它来携带最高的prepareQC。在副本角色中发送的每条消息都包含一个部分签名m.partialSig，由发送者在〈m.type, m.viewNumber , m.node〉上签名，该签名被添加到voteMsg()工具中。</p><p>**法定人数证书。**一个关于元组〈type, viewNumber , node〉的Quorum Certicate（QC）是一个数据类型，它结合了由（n - f）个副本签署的同一元组的签名集合。给定一个QC qc，我们用qc.type, qc.viewNumber , qc.node来指代原始元组的匹配字段。</p><p><strong>树和分支</strong>。每个命令都被包裹在一个节点中，该节点还包含一个父节点链接，该链接可以是父节点的哈希摘要。我们省略了伪代码中的实现细节。在协议中，一个副本只有在节点leader节点的分支已经在其本地树中之后才会传递消息。在实践中，落后的接收者可以通过从其他副本中获取缺失的节点来追赶。为了简洁起见，这些细节也从伪代码中省略了。如果两个分支都不是另一个分支的延伸，那么这两个分支就是相互矛盾的。如果两个节点所leader节点的分支是相互矛盾的，那么这两个节点就是相互矛盾的。</p><p>**簿记变量。**复制体使用额外的本地变量来保存协议状态：(i) viewNumber，最初为1，通过完成决策或下一个View中断而增加；(ii) lock quorum certicate locked QC，最初为⊥，存储复制体投票提交的最高QC；以及(iii) prepareQC，最初为⊥，存储复制体投票预提交的最高QC。此外，为了递增地执行已提交的命令日志，复制体维护其分支已被执行的最高节点。为了简洁起见，下面省略了这一点。</p><h3 id="43协议规范"><a class="markdownIt-Anchor" href="#43协议规范"></a> 4.3协议规范</h3><p>​算法2中给出的协议被描述为一个迭代的逐个视图的循环。在每个视图中，一个复制体根据其角色连续执行各个阶段，描述为连续的 "作为 "块。一个副本可以有一个以上的角色。例如，一个leader也是一个（正常的）副本。角色间的作为块的执行可以同时进行。每个as块的执行都是原子性的。nextView的中断中止了任何as块中的所有操作，并跳转到 "Final "块。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210140949044.png" alt="image-20221014094925966"></p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210140949230.png" alt="image-20221014094940152"></p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210140950785.png" alt="image-20221014095001709"></p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210140950152.png" alt="image-20221014095058109"></p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210140951177.png" alt="image-20221014095116123"></p><p>4.4安全，活性和复杂性</p><p>安全性。我们首先认为，如果tverify(〈qc.type, qc.viewNumber , qc.node〉, qc.sig)为真，则法定人数证书qc为有效。</p><p>推理1。对于任何有效的qc1, qc2，其中qc1.type = qc2.type并且qc1.node与qc2.node冲突，我们有qc1.viewNumber 6= qc2.viewNumber 。</p><p>证明。为了显示矛盾，假设qc1.viewNumber = qc2.viewNumber = v。因为一个有效的QC只能在有n - f = 2f + 1票（即部分签名）的情况下形成，必须有一个正确的复制品在v的同一阶段投票两次。</p><p>定理2. 如果w和b是对立的节点，那么它们不可能同时被承诺，各自被一个正确的副本承诺。</p><p>证明。我们通过矛盾法来证明这一重要定理。让qc1表示一个有效的commitQC（即qc1.type = commit），这样qc1.node = w；qc2表示一个有效的commitQC，这样qc2.node = b。根据定理1，v1 6= v2.假设v1 &lt; v2.</p><p>​我们现在用vs表示比v1高的最低视图，对于它有一个有效的prepareQC，qcs（即qcs.type = prepare），其中qcs.viewNumber = vs，并且qcs.node与w一致。</p><p>E(prepareQC ) :=(v1 &lt; prepareQC .viewNumber ≤ v2) ∧ (prepareQC .node conicts with w).</p><p>现在我们可以设置第一个开关点qcs。</p><p>qcs := arg min prepare QC {prepareQC .viewNumber | prepareQC is valid ∧ E(prepareQC )} .</p><p>请注意，根据假设，这样的qcs必须存在；例如，qcs可能是在视图v2中形成的prepareQC。</p><p>​在发送部分结果tsignr(〈qc1.type, qc1.viewNumber , qc1.node〉)的正确副本中，让r成为第一个贡献tsignr(〈qcs.type, qcs.viewNumber , qcs.node〉的副本；这样的r一定存在，因为否则qc1.sig和qcs.sig之一不可能被创建。在视图v1期间，副本r在算法2的第25行将其锁定的QC更新为w上的precommitQC。由于vs的最小化，在qcs形成之前，复制体r在w所带领的分支上的锁没有被改变。否则，r一定看到了其他的prepareQC，而且视图较低，因为第17行在第25行之前，与最小性相矛盾。现在考虑复制体r在视图vs的准备阶段对safeNode的调用，消息m携带m.node = qcs.node。根据假设，m.node与锁定的QC.node相冲突，因此算法1第26行的disjunct为假。此外，m.justify.viewNumber &gt; v1将违反vs的最小化原则，因此算法1第27行的disjunct也是假的。因此，safeNode必须返回false，并且r不能对视图vs中的矛盾分支投准备票，这是一个矛盾。</p><p>​有效性。在上一节中，有两个函数没有提到：leader和nextView。它们的命名不会影响到协议的安全性，但它们确实关系到有效性。在给出它们的候选名称之前，我们首先表明，在GST之后，有一个有约束的持续时间Tf，如果在Tf期间所有正确的复制都留在视图v中，并且视图v的leader是正确的，那么就会达成一个决定。下面我们说，如果qc1和qc2是有效的，qc1.node = qc2.node，并且qc1.viewNumber = qc2.viewNumber，则qc1和qc2是匹配的。</p><p>​推理3. 如果一个正确的副本被锁定，使得锁定的QC=预提交的QC，那么至少有f+1个正确的副本投票给一些与锁定的QC匹配的prepareQC。</p><p>​证明。假设副本r被锁定在precommitQC上。那么，在准备阶段（算法2的第10行），有（n-f）票投给了匹配的prepareQC，其中至少有f+1票是来自正确的副本。</p><p>​定理4. 在GST之后，存在一个有界的时间段Tf，如果在Tf期间所有正确的复制都留在视图v中，并且视图v的leader是正确的，那么就会达成一个决定。</p><p>​证明。从一个新视图开始，leader收集(n - f )个新视图消息，并在广播prepare messsage之前计算它的highQC。假设在所有的副本中（包括leader本身），保持最高的锁是锁定的QC = precommitQC ∗。根据定理3，我们知道至少有f+1个正确的副本投票选出了与precommitQC ∗相匹配的prepareQC，并且已经在他们的new-view消息中把它们发送给了leader。因此，leader必须在这些新视图消息中至少有一个学到匹配的prepareQC ∗，并在其prepare消息中使用它作为highQC。根据假设，所有正确的副本在他们的视图中都是同步的，并且leader是无故障的。因此，所有正确的复制体都会在准备阶段投票，因为在safeNode中，算法1第27行的条件是满足的（即使消息中的节点与复制体的陈旧锁定的QC.节点相冲突，因此第26行不是）。然后，在leader为这个视图组装了一个有效的prepareQC之后，所有的副本将在接下来的所有阶段进行投票，导致一个新的决定。在GST之后，这些阶段完成的持续时间Tf是有边界的长度。</p><p>​该协议是乐观响应的，因为没有明确的 "等待-∆"步骤，而且safeNode中的逻辑分离被用来在三阶段范式的帮助下覆盖一个过时的锁。</p><p>​我们现在为leader和nextView提供了简单的结构，以确保在GST之后，最终会达到一个视图，其中leader是正确的，所有正确的副本在Tf时间内保持在这个视图中。对于leader来说，它成功地返回了一些从视图编号到副本的确定性映射，最终在所有的副本中轮换。nextView的一个可能的解决方案是利用一个保持超时时间间隔的指数型退避机制。然后在进入每个视图时设置一个定时器。当定时器熄灭而没有做出任何决定时，复制体将间隔时间加倍，并调用nextView来推进视图。由于每次的时间间隔都会翻倍，所有正确的副本的等待时间间隔最终会有至少Tf的共同重叠，在此期间，leader可以驱动一个决定。</p><p>​**两相的无生气。**我们现在展示了一个 "两阶段 "HotStuff的先天非决定性情景。这解释了在Casper和Tendermint中引入同步延迟的必要性，因此也解释了放弃（乐观的）响应性的必要性。</p><p>​在两阶段的HotStuff变体中，我们省略预提交阶段，直接进行提交。当一个副本在prepareQC上投票时，它就会被锁定。假设在视图v中，一个leader提出了b。它完成了准备阶段，一些副本rv对prepareQC进行了投票，比如qc，使得qc.node = b。一个异步的网络调度导致其余的副本在没有收到qc的情况下移动到视图v+1。</p><p>​我们现在无休止地重复下面的单视图记录。我们从视图v+1开始，只有rv持有系统中最高的prepareQC（即qc）。新的leaderl从2f + 1个副本中收集新的视图信息，不包括rv。其中最高的prepareQC，qc′，拥有视图v-1，b′=qc′.节点与b冲突。然后，l提出了扩展b′的b′，2个诚实的复制体以投票方式回应，但是rv拒绝了它，因为它被锁在qc上，b′与b冲突，而且qc′比qc低。最终，有2个复制体放弃了，转到了下一个视图。就在这时，一个有问题的副本回应了我的提议，然后我提出了一个prepareQC（v+1，b′′），一个副本，比如说rv+1，投票给它，并锁定在它上面。</p><p>​复杂性。在HotStuff的每个阶段，只有leader向所有副本进行广播，而副本则以部分签名的方式回应发送者一次，以证明投票。在leader的信息中，QC由之前收集的(n - f )票数证明组成，它可以由一个阈值签名来编码。在一个副本的回应中，来自该副本的部分签名是唯一的认证者。因此，在每个阶段，总共有O(n)个认证器被收到。由于阶段的数量是恒定的，每个视图的总体复杂度是O(n)。</p><p>5.链式的hotstuff</p><p>​一个基本的HotStuffleader需要三个阶段来提交一个提案。这些阶段除了从副本中收集投票外，并不做 "有用 "的工作，而且它们都非常相似。在Chained HotStuff中，我们改进了Basic HotStuff协议的实用性，同时也大大简化了它。我们的想法是在每个准备阶段改变视图，因此每个提案都有自己的视图。这就减少了消息类型的数量，并允许对决策进行流水线处理。在Casper[1]中提出了一个类似的减少消息类型的方法。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141021023.png" alt="image-20221014102135968"></p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141021759.png" alt="image-20221014102144728"></p><p>图1：链式HotStuff是一种流水线式的基本HotStuff，其中一个QC可以同时服务于不同阶段。</p><p>图2：视图v4、v5、v6的节点形成了一个三链。视图v8的节点在Chained HotStuff中不构成有效的One-Chain（但在第6节的算法中放松后，它是一个有效的One-Chain）。</p><p>​更具体地说，在Chained HotStuff中，准备阶段的投票被leader收集到一个通用的QC中。然后，genericQC被转发给下一个视图的leader，本质上是将下一个阶段的责任委托给下一个leader，而这个阶段本来是预提交的。然而，下一个leader实际上并没有进行预承诺阶段，而是启动了一个新的准备阶段并增加了自己的提议。视图v+1的准备阶段同时作为视图v的预提交阶段。视图v+2的准备阶段同时作为视图v+1的预提交阶段和视图v的提交阶段。</p><p>​图1描述了嵌入链式HotStuff提案链中的基本HotStuff协议阶段的流水线。Chained HotStuff的视图v1、v2、v3作为v1中提议的cmd1的准备、预提交和提交基本HotStuff阶段，该命令在v4结束时被提交。 视图v2、v3、v4作为v2中提议的cmd2的三个基本HotStuff阶段，它在v5结束时被提交。 这些阶段产生的其他提议以类似方式继续管道，并以虚线框表示。在图1中，单箭头表示节点b的b.parenteld，双箭头表示b.justify.node。</p><p>​因此，在Chained HotStuff中只有两种类型的消息，一种是新视图消息，一种是通用阶段通用消息。通用QC在所有的逻辑流水线阶段都有作用。接下来，我们将解释管道中的机制，以照顾锁定和提交，这只发生在Basic HotStuff的提交和决定阶段。</p><p>​虚设节点。某个视图viewNumber中的leader节点所使用的通用QC可能不会直接引用前一个视图（viewNumber-1）的提议。原因是前一个视图的leader节点未能获得QC，要么是因为有相互矛盾的提议，要么是因为良性崩溃。为了简化树形结构，createLeaf用空白节点扩展了genericQC .node，直到提议视图的高度（节点分支上的父链接数），因此视图编号等同于节点高度。因此，嵌入节点b中的QC可能并不指它的父节点，也就是说，b.justify.node可能不等于b.parent（图2中的最后一个节点）。</p><p>​一链、二链和三链。当一个节点b∗携带一个指向直接父节点的QC，即b∗.justify.node = b∗.parent，我们就说它形成了一个One-Chain。用b′′＝b∗.justify.node表示。如果节点b∗除了形成一个一链之外，b′′.justify.node = b′′.parent，则形成一个二链。如果b′′形成一个二链，它就形成一个三链。</p><p>​看一下链b = b′.justify.node, b′ = b′′.justify.node, b′′ = b∗.justify.node，祖先的差距可能发生在任何一个节点。这些情况类似于Basic HotStuff的leader未能完成三个阶段中的任何一个，被nextView打断到下一个视图。</p><p>​如果b∗形成了一个单链，那么b′′的准备阶段就成功了。因此，当一个副本为b∗投票时，它应该记住genericQC ← b∗.justify。我们注意到，即使在One-Chain不直接的情况下，更新genericQC也是安全的，只要它比当前的genericQC高。在第6节描述的实现代码中，我们确实在这种情况下更新了genericQC。</p><p>​如果b∗形成了一个双链，那么b′的预提交阶段就成功了。因此，副本应该更新锁定的QC← b′′.justify。我们再次指出，即使在二链不直接的情况下，锁也可以被更新–安全不会被破坏–事实上，这在第6节的实现代码中已经给出。</p><p>​最后，如果b∗形成了一个三链，那么b的提交阶段就成功了，b就成了一个承诺的决策。</p><p>​算法3显示了链式HotStuff的伪代码。附录A中的定理5所给出的安全性证明与Basic HotStuff的类似。我们要求有效节点中的QC指的是其祖先。为简洁起见，我们假设该约束总是成立，并在代码中省略检查。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141040289.png" alt="image-20221014104034227"></p><h2 id="6实施"><a class="markdownIt-Anchor" href="#6实施"></a> 6.实施</h2><p>​HotStuff是一个实用的协议，用于构建古老的SMR系统。由于其简单性，我们可以很容易地将算法3变成一个事件驱动式的规范，它几乎就像一个原型实现的代码骨架。</p><p>​如算法4所示，该代码被进一步简化和泛化，从本体中提取出有效性机制，放入一个名为Pacemaker的模块。在通用阶段结束时，下一个leader总是等待一个通用的QC，然后开始它的统治，而不是把这个逻辑委托给Pacemaker。一个稳定的leader可以跳过这个步骤，在多个高度上精简提案。</p><p>​此外，我们放宽了保持最高通用QC和锁定QC的直接父约束，同时仍然保留了有效节点中的QC总是指其祖先的要求。正确性的证明与Chained HotStuff相似，我们也将其推迟到[50]的附录中。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141042299.png" alt="image-20221014104232261"></p><p>​它还保持一个常数b0，即所有正确的副本都知道的同一个创世节点。为了引导，b0包含了一个硬编码的QC，block、bexec、bleaf都被初始化为b0，qchigh包含b0的QC。</p><p>​起搏器。起搏器是一种保证在GST之后取得进展的机制。它通过两种成分实现这一目标。</p><p>​第一种是 “同步化”，将所有正确的复制体和唯一的leader带到一个共同的高度，并保持足够长的时间。文献[25, 20, 15]中通常的同步机制是让复制体增加它们在更大高度上花费的∆的数量，直到取得进展。确定性地选举leader的一个常见方法是使用轮流leader方案，其中所有正确的副本保持预先设定的leader时间表，并在leader被降级时轮流到下一个。</p><p>​其次，起搏器需要为leader提供一种方法来选择一个将被正确的副本所支持的提议。如算法5所示，在视图改变后，在onReceiveNewView中，新的leader通过onNextSyncView收集复制体发送的新视图消息，以发现最高的QC，满足onReceiveProposal中第二部分条件的有效性（算法4的第18行）。然而，在同一视图中，现任leader节点将把新节点链到自己最后提议的叶子的末端，这里不需要新视图消息。基于一些应用特有的启发式方法（例如，等到之前提议的节点获得QC），现任leader会调用onBeat来提议一个携带命令的新节点来执行。</p><p>​值得注意的是，即使一个坏的起搏器任意调用onPropose，或者任性地选择一个父类和一个QC，并且在任何调度延迟的情况下，安全性总是得到保证的。因此，仅由算法4保证的安全性与算法5的任何潜在实例化的有效性完全脱钩。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141044708.png" alt="image-20221014104403646"></p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141044496.png" alt="image-20221014104416453"></p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141044313.png" alt="image-20221014104424276"></p><p>两阶段的HotStuff变体。为了进一步证明HotStuff框架的灵活性，算法6显示了HotStuff的两阶段变体。只有更新程序受到影响，达成提交决定需要双链，而单链则决定锁。如上所述（第4.4节），这种两阶段变体失去了优化响应性，与Tendermint/Casper类似。它的好处是阶段更少，同时可以通过在Pacemaker中加入一个基于最大网络延迟的等待来解决失效性问题。进一步的讨论见第7.3节。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141044789.png" alt="image-20221014104447742"></p><p>7.单链和双链</p><p>​在本节中，我们研究了横跨拜占庭容错领域四十年研究的四种BFT复制协议，将它们投射到类似于Chained HotStuff的连锁框架中。</p><p>​图3提供了我们所考虑的ve协议的提交规则的鸟瞰图，包括HotStuff。</p><p>​简而言之，DLS[25]中的提交规则是一链式的，只允许一个节点被自己的leader提交。PBFT[20]、Tendermint[15, 16]和Casper[17]的提交规则几乎相同，都是双链的。它们的不同之处在于它们引入的有效性机制，PBFT有二次大小的leader “证明”（没有线性），Tendermint和Casper在每个leader提议之前引入一个强制性的∆延迟（没有优化响应性）。HotStuff使用三链规则，并且有一个没有延迟的线性leader协议。</p><p>7.1DLS</p><p>​最简单的提交规则是一链式的。这个规则以Dwork, Lynch, and Stockmeyer (DLS)为模型，是第一个已知的异步拜占庭共识解决方案，如图3（a）所示。一个副本在DLS中被锁定在它投票支持的最高节点上。</p><p>​不幸的是，如果在某个高度，一个leader含糊其辞，而两个正确的复制品在该高度被锁定在相互矛盾的提案上，那么这个规则将很容易导致僵局。放弃任何一个锁都是不安全的，除非有2f+1表示他们没有投票给锁定的值。</p><p>​事实上，在 DLS 中，只有每个高度的leader自己可以通过一链式提交规则达成提交决定。因此，只有leader本身在犹豫不决的情况下才会受到伤害。如果2f+1个副本没有投票支持，或者有相互矛盾的提议（由leader签署），那么副本可以放弃一个锁。在DLS的每个高度结束时发生的解锁协议被证明是相当复杂和昂贵的。再加上一个事实，即只有一个高度的leader可以决定，在最好的情况下，没有故障发生，网络是及时的，DLS需要n个leader轮换，以及O(n4)消息传输，每一个决定。虽然它在展示一个安全的异步协议方面有了新的突破，但DLS并不是作为一个实用的解决方案而设计的。</p><p>7.2pbft</p><p>​以PBFT为模型，一个更实用的Appraoch使用双链提交规则，见图3（b）。当一个副本投票给一个形成一链的节点时，它就被锁定在该节点上。由于每个节点都有一个QC，所以在同一高度上的相互矛盾的One-Chain是不可能的，因此可以避免DLS的死锁情况。</p><p>​然而，如果一个副本拥有比其他副本更高的锁，即使leader收集了n-f个副本的信息，也可能不知道它的情况。这可能会阻止leader无休止地达成决定，纯粹是由于调度的原因。为了得到 “解锁”，PBFT通过携带由2f+1个副本组成的最高一链的证明来解锁所有副本。这个证明是相当复杂的，如下所述。</p><p>​原始的PBFT已经开源[20]，并在一些后续工作中采用[13, 34]，leader证明包含一组从n-f个副本中收集的信息，报告每个成员投票支持的最高一链。每个One-Chain都包含一个QC，因此总的通信成本是O(n3)。利用来自[45, 18]的签名组合方法，SBFT[30]通过将每个QC变成一个单一的值，将这个成本降低到O(n2)。</p><p>​在[21]中的PBFT变体中，leader证明只包含leader从法定人数中收集到的最高一链一次。它还包括法定人数中每个成员的一个签名值，证明它没有投票给更高的一链。广播这个证明会产生通信复杂度O(n2)。请注意，虽然QC上的签名可以合并成一个单一的值，但整个证明不能减少到恒定的大小，因为来自法定人数中不同成员的消息可能有不同的值。</p><p>​在这两个变体中，一个正确的复制品即使比leader的证明具有更高的一链，也会被解锁。因此，一个正确的leader可以在同步期间强制接受其提议，并且保证了有效性。每个leader的替换成本是二次通信。</p><p>7.3 Tendermint和Casper</p><p>​Tendermint有一个与PBFT相同的双链提交规则，而Casper有一个双链规则，其中叶子不需要有QC来指导父本。也就是说，在Casper中，图3（c,d）分别描述了Tendermint和Casper的提交规则。</p><p>​在这两种方法中，leader只需将它所知道的最高的One-Chain与它的提议一起发送。如果一个副本从leader那里收到更高的一链，它就会解锁一链。</p><p>​然而，由于正确的副本可能不会为leader的节点投票，为了保证进展，新的leader必须通过等待最大的网络延迟来获得最高的One-Chain。否则，如果leader只等待前n-f个信息来开始一个新的高度，就没有进展保证。leader延迟在Tendermint和Casper中都是固有的，目的是为了提供灵活性。</p><p>​这个简单的leader协议体现了leader协议的通信复杂性的线性飞跃，HotStuff借用了这个协议。正如上面已经提到的，QC可以通过使用阈值签名来捕获一个单一的值，因此leader可以以线性通信复杂度收集和传播最高的One-Chain。然而，至关重要的是，由于额外的QC步骤，HotStuff不要求leader等待最大的网络延迟。</p><p>8.评价</p><p>我们将HotStuff作为一个库来实现，大约有4K行的C++代码。最明显的是，伪代码中规定的核心共识逻辑只消耗了大约200行。在这一节中，我们将首先通过与最先进的系统BFT-MaRt[13]的比较来检查基线吞吐量和延迟。然后，我们将关注视图变化的消息成本，以了解我们在这种情况下的优势。</p><p>8.1 设置</p><p>​我们在亚马逊EC2上使用c5.4xlarge实例进行了实验。每个实例有16个vCPU，由英特尔至强白金8000处理器支持。所有核心的CPU时钟速度都达到了3.4GHz。我们在单个虚拟机实例上运行每个副本，因此大量使用线程的BFT-MaRt被允许利用每个副本的16个核心，就像他们最初的评估[13]一样。iperf测量的最大TCP带宽约为每秒1.2千兆字节。我们在任何运行中都没有对带宽进行节制。两台机器之间的网络延迟小于1毫秒。</p><p>​我们的HotStuff原型实现在投票和法定人数证书中都使用secp256k1作为所有数字签名。BFT-MaRt在正常运行期间对消息中的MAC（消息验证码）使用hmac-sha1，在视图变化期间除了MAC之外还使用数字签名。</p><p>​HotStuff的所有结果都反映了客户端的端到端测量。对于BFT-MaRt，我们使用了BFT-MaRt网站（<a href="https://github.com/bft-smart/library%EF%BC%89%E4%B8%8A%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E7%A8%8B%E5%BA%8FToughputLatencyServer%E5%92%8CToughputLatencyClient%E3%80%82%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A8%8B%E5%BA%8F%E6%B5%8B%E9%87%8F%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E5%BB%B6%E8%BF%9F%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%B5%8B%E9%87%8F%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%8C%E8%80%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%97%B6%E6%B5%8B%E9%87%8F%E5%90%9E%E5%90%90%E9%87%8F%E5%92%8C%E5%BB%B6%E8%BF%9F%E3%80%82%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E4%BA%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F%E7%BB%93%E6%9E%9C%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%BB%B6%E6%97%B6%E7%BB%93%E6%9E%9C%E3%80%82">https://github.com/bft-smart/library）上的微基准程序ToughputLatencyServer和ToughputLatencyClient。客户端程序测量端到端的延迟，但不测量吞吐量，而服务器端程序同时测量吞吐量和延迟。我们使用了服务器的吞吐量结果和客户端的延时结果。</a></p><h3 id="82-基础性能"><a class="markdownIt-Anchor" href="#82-基础性能"></a> 8.2 基础性能</h3><p>​我们首先测量了其他BFT复制系统评估中常见的吞吐量和延时。我们在一个能容忍单一故障的集合中运行4个副本，即f=1，同时改变操作请求率直到系统饱和。这个基准使用了空的（零大小）操作请求和响应，并且没有触发视图变化；我们在下面扩展到其他设置。虽然我们的响应式HotStuff是三阶段的，但我们也运行其两阶段的变体作为额外的基线，因为BFT-MaRt基线只有两个阶段。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141443179.png" alt="image-20221014144311135"></p><p>图4：不同的批处理规模选择下的吞吐量与延迟，4个副本，0/0有效载荷。</p><p>图5：在不同的有效载荷大小选择下，吞吐量与延迟的关系，4个副本，批次大小为400。</p><p>​图4描述了两个系统的三种批处理规模：100、400和800，不过由于这些系统有不同的批处理方案，这些数字对每个系统的意义略有不同。BFT-MaRt为每个操作驱动一个单独的共识决策，并对来自多个共识协议的消息进行批处理。因此，它有一个典型的L型延迟/吞吐量性能曲线。HotStuff在每个节点批处理多个操作，并以这种方式减轻了每个决策的数字签名成本。然而，每批操作超过400次，批处理所产生的延迟就会高于加密的成本。尽管存在这些差异，三相（“HS3-”）和两相（“HS2-”）HotStuff在所有三种批处理规模下都取得了与BFT-MaRt（“BS-”）相当的延迟性能，而其最大吞吐量明显优于BFT-MaRt。</p><p>​对于100和400的批处理量，最低延迟的HotStuff点提供的延迟和吞吐量优于BFT-MaRT在其最高吞吐量下可同时实现的延迟和吞吐量，同时会产生少量的延迟增加。这种增加部分是由于HotStuff采用的批处理策略。它需要另外三个完整的批处理（在两阶段的变体中是两个）来达成对一个批次的决定。我们的实验保持了较高的未决请求数量，但批处理规模越大，批处理管道所需的时间就越长。实际部署可以进一步优化，以使批处理规模适应未完成操作的数量。</p><p>图5描述了0/0、128/128和1024/1024三种客户端请求/回复的有效载荷大小（以字节为单位），分别表示为 “p0”、"p128 "和 “p1024”。在所有的有效载荷大小中，三相和两相HotStuff的吞吐量都超过了BFTSMaRt，而延迟相似或相当。</p><p>​注意BFT-MaRt使用基于对称加密的MAC，比HotStuff使用的数字签名中的非对称加密快几个数量级，而且与BFT-MaRt使用的两相PBFT变体相比，三相HotStuff的往返次数更多。 但HotStuff仍然能够实现可比的延迟和高得多的吞吐量。下面我们将在更具挑战性的情况下评估这两个系统，HotStuff的性能优势将变得更加明显。</p><p>8.3 可扩展性</p><p>​为了评估HotStuff在不同维度上的可扩展性，我们进行了三个实验。对于基线，我们使用零尺寸的请求/响应有效载荷，同时改变副本的数量。第二次评估用128字节和1024字节的请求/响应有效载荷重复基线实验。第三项测试重复了基线（空的有效载荷），同时引入了副本之间的网络延迟，这些网络延迟均匀分布在5ms±0.5ms或10ms±1.0ms，用NetEm实现（见https://www.linux.org/docs/man8/tc-netem.html）。对于每个数据点，我们用相同的设置重复运行了多次，并显示了误差条以表示所有运行的标准偏差。</p><p>​图6a（吞吐量）和图6b（延迟）中描述了第一种设置。三相和两相HotStuff都显示出持续优于BFT-MaRt的吞吐量，而它们的延迟仍可与具有优雅降级的BFTSMaRt相比。当n&lt;32时，性能的扩展性比BFT-MaRt好。这是因为我们目前仍然使用secp256k1签名列表来进行QC。在未来，我们计划通过使用快速阈值签名方案来减少HotStuff的加密计算开销。</p><p>​图7a（吞吐量）和图7b（延迟）中用 "p128 "或 "p1024 "表示有效载荷大小为128或1024字节的第二个设置。由于其二次带宽成本，对于合理的大（1024字节）有效载荷大小，BFT-SMaRt的吞吐量比HotStuff差。</p><p>​第三种设置在图8a（吞吐量）和图8b（延迟）中显示为 "5ms "或 “10ms”。同样，由于BFT-MaRt中通信的使用量较大，HotStuff在这两种情况下的表现始终优于BFT-MaRt。</p><p>8.4 视图变化</p><p>​为了评估leader替换的通信复杂性，我们计算了在BFT-MaRt的视图变化协议中进行的MAC或签名验证的数量。我们的评估策略如下。我们在BFT-MaRt中每隔一千次决策就注入一次视图变化。我们对BFT-MaRt的源代码进行了检测</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141447544.png" alt="image-20221014144707468"></p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141447457.png" alt="image-20221014144716411"></p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141447786.png" alt="image-20221014144727731"></p><p>​代码来计算接收和处理视图变化协议中的信息时的验证次数。除了通信复杂性之外，这种测量还强调了与传输这些验证值相关的加密计算负荷。</p><p>​图9a和图9b显示了每次视图变化所处理的额外验证器（分别为MAC和签名）的数量，其中 "额外 "被认为是那些如果leader节点保持稳定就不会发送的验证器。请注意，HotStuff没有 "额外 "的认证器，因为无论leader是否保持不变，认证器的数量都是一样的。这两张图显示，BFT-MaRt使用了立方数的MAC和二次数的签名。HotStuff不需要额外的认证器来改变视图，所以从图中省略了。</p><p>​评估leader替换的实时性能是很棘手的。首先，BFT-MaRt在触发频繁的视图变化时卡住了；我们的认证器计数基准必须在系统卡住之前尽可能多地对成功的视图变化进行平均，重复实验多次。第二，leader替换的实际耗时高度依赖于超时参数和leader选举机制。因此，不可能提供一个有意义的比较。</p><p>9 结论</p><p>​自从PBFT–部分同步模型中第一个实用的BFT复制解决方案问世以来，许多BFT解决方案都是围绕其核心的两阶段范式建立的。第一阶段通过QC保证提案的唯一性。第二阶段保证新的leader能够说服复制体投票支持一个安全的提案。这需要leader从(n-f)个副本中传递信息，每个副本报告自己的最高QC或投票。一代又一代的两阶段工作因此在leader更换时遭遇了二次通信瓶颈。</p><p>​HotStuff围绕着一个三阶段的核心，允许新的leader简单地挑选它所知道的最高QC。这减轻了上述复杂性，同时也大大简化了leader替换协议。在（几乎）规范了各个阶段之后，HotStuff的流水线就非常容易了，而且可以经常轮换leader节点。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141448697.png" alt="image-20221014144845632"></p><p>附录</p><p>链式HotStuff的安全证明</p><p>定理5。让b和w是两个对立的节点。那么它们不能同时被一个诚实的副本承诺。证明。我们通过矛盾法来证明这个定理。通过类似于Lemma 1的论证，b和w必须在不同的视图中。假设在一个ectuion中，b通过QC三链b, b′, b′′, b∗在某个诚实的副本中被承诺，同样地，w通过QC三链w, w′, w′′, w∗在某个诚实的副本中被承诺。由于b, b′, b′′, w, w′, w′′中的每一个都得到了它的QC，那么，我们假设b是在比w′′高的视图中创建的，即b′.justify.viewNumber &gt; w∗.justify.viewNumber ，如图11所示。现在我们用vs表示高于vw′′=w∗.justify.viewNumber的最低视图，其中有一个qcs，使qcs.node与w相冲突。形式上，我们对任何qc下达以下谓语。</p><p>​E(qc) :=(vw′′ &lt; qc.viewNumber ≤ vb) ∧ (qc.node conicts with w) 。我们现在可以设置第一个切换点qcs：qcs := arg min qc {qc.viewNumber | qc is valid ∧ E(qc)}。</p><p>​根据假设，这样的qcs存在，例如，qcs可以是b′.justify。让r表示w∗.justify和qcs的交集中的一个正确副本。根据qcs最小化的假设，在qcs形成之前，r对w的锁不会被改变。现在考虑r在视图vs中调用safeNode，消息m携带一个有争议的节点m.node = qcs.node。根据假设，锁的条件（算法1的第26行）是假的。另一方面，该协议要求t = m.node.justify.node是qcs.node的祖先。根据qcs的最小性，m.node.justify.viewNumber≤vw′′。由于qcs.node与w冲突，t不能是w、w′或w′′。那么，m.node.justify.viewNumber &lt; w′.justify.viewNumber ，所以另一半的disjunct也是假的。因此，r不会投票给qcs.node，与r的假设相矛盾。</p><p>​有效性论证几乎与Basic HotStuff相同，只是我们必须假设在GST之后，连续两个leader节点是正确的，以保证决策。为了简洁起见，我们省略了这一点。</p><p>B 实施的安全证明</p><p>伪码 6. 假设b和w是两个相互矛盾的节点，使得b.height = w.height，那么它们就不能同时拥有有效的法定人数证书。证明。假设他们可以，那么b和w都得到了2f+1票，其中至少有f+1个诚实的副本为每个节点投票，那么一定有一个诚实的副本为两个节点投票，这是不可能的，因为b和w的高度是一样的。符号1. 对于任何节点b，让"←"表示父关系，即b.parent ← b.让"∗ ←"表示祖先关系，即父关系的反演闭合。那么，两个节点b，w是矛盾的，如果b ∗ ←w∧w ∗ ← b。让"⇐"表示QC所指的节点，即b.justify.node ⇐ b。让b和w是两个相互矛盾的节点。那么它们不可能同时被一个诚实的复制品承诺。证明。我们通过矛盾法来证明这个重要的定理。让b和w是两个处于不同高度的冲突节点。假设在执行过程中，b通过QC三链b(⇐ ∧ ← )b′(⇐ ∧ ←)b′′ ⇐ b∗在某个诚实的副本中成为承诺。同样地，通过QC三链w(⇐ ∧ ← )w′(⇐ ∧ ←)w′ ⇐ w∗，w在某个诚实的副本中成为承诺。根据定理1，由于每个节点b, b′, b′′, w, w′, w′′都有QC，那么，我们假设b.height &gt; w′′.height，如图11所示。现在我们用qcs来表示高度小于w′′.height的节点的QC，该节点与w相冲突。E(qc) := (w′′.height &lt; qc.node.height ≤ b.height) ∧ (qc.node conicts with w) 我们现在可以设置第一个转换点qcs: qcs := arg min qc {qc.node.height | qc is valid ∧ E(qc)}。根据假设，这样的qcs存在，例如，qcs可以是b′.justify。让r表示w∗.justify和qcs相交处的一个正确副本。根据qcs最小化的假设，在qcs形成之前，r对w的锁不会被改变。现在考虑对onReceiveProposal的调用，该消息携带一个有争议的节点bnew，这样bnew=qcs.node。根据假设，锁的条件（算法4的第17行）是假的。另一方面，协议要求t = bnew .justify.node是bnew的祖先。 根据qcs的最小性，t.高度≤w′′.高度。由于qcs.node与w相冲突，t不能是w、w′或w′′。那么，t.height&lt;w.height，所以另一半的disjunct也是假的。因此，r不会投票给bnew，与r的假设相矛盾。 定理8。假设cmd 1和cmd 2是任意两个命令，其中cmd 1在cmd 2之前被某个诚实的副本执行，那么任何执行cmd 2的诚实副本都必须在cmd 2之前执行cmd 1。证明。用w表示携带cmd1的节点，b携带cmd2的节点。从Lemma 6可以看出，承诺的节点处于不同的高度。在不丧失一般性的情况下，假设w.height&lt;b.height。w和b的提交是由更新中的onCommit(w′)和onCommit(b′)触发的，其中w ∗ ← w′，b ∗ ← b′。根据Lemma 7，w′一定不会与b′冲突，所以w不会与b冲突。然后w ∗ ← b，当任何诚实的副本执行b时，它一定会通过onCommit的递归逻辑首先执行w。</p><p>B.1 备注 为了深入了解HotStuff设计中的权衡，我们解释了为什么某些约束对于安全是必要的。</p><p>为什么是单调的vheight？假设我们改变投票规则，使副本不需要单调地投票，只要它不对每个高度投票超过一次。削弱后的约束会破坏安全性。例如，一个副本可以先为b投票，然后为w投票。在了解b′，b′′之前，它首先交付w′，w′′，假设锁在w上，并为w′′投票。当它最终交付b′′时，它将ip到bleader节点的分支，因为它有资格被锁定，而且b比w高。最后，副本也将投票给b′′，导致w和b的提交。直接父约束被用来确保证明中使用的等价物b.height&gt;w′′.height，在Lemma 6的帮助下。假设我们不执行提交规则，所以提交约束被弱化为w ∗ ← w′ ∗ ← w′，而不是w ← w′ ← w′（对b也一样）。考虑一下w′.height &lt; b.height &lt; b′.height &lt; w′′.height &lt; b′′.height的情况。有可能，一个副本可以先投票给w′′，然后发现b′′，切换到b的分支，但这已经太晚了，因为w可能已经提交了。</p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><h2 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h2><span id="more"></span><h2 id="研究问题"><a class="markdownIt-Anchor" href="#研究问题"></a> 研究问题</h2><h3 id="研究背景简要介绍"><a class="markdownIt-Anchor" href="#研究背景简要介绍"></a> 研究背景(简要介绍)</h3><h3 id="研究问题或解决技术问题描述需定位和描述清晰"><a class="markdownIt-Anchor" href="#研究问题或解决技术问题描述需定位和描述清晰"></a> 研究问题或解决技术问题描述（需定位和描述清晰）</h3><h2 id="研究现状"><a class="markdownIt-Anchor" href="#研究现状"></a> 研究现状</h2><h3 id="围绕研究问题进行相关研究成果列举注明参考文献"><a class="markdownIt-Anchor" href="#围绕研究问题进行相关研究成果列举注明参考文献"></a> 围绕研究问题，进行相关研究成果列举（注明参考文献）</h3><h3 id="研究现状总结及现有研究仍然存在不足或问题"><a class="markdownIt-Anchor" href="#研究现状总结及现有研究仍然存在不足或问题"></a> 研究现状总结，及现有研究仍然存在不足或问题</h3><h2 id="思路特色"><a class="markdownIt-Anchor" href="#思路特色"></a> 思路特色</h2><h3 id="与现有研究技术手段不同之处"><a class="markdownIt-Anchor" href="#与现有研究技术手段不同之处"></a> 与现有研究（技术手段）不同之处</h3><h2 id="关键问题技术点"><a class="markdownIt-Anchor" href="#关键问题技术点"></a> 关键问题/技术点</h2><h3 id="围绕研究题目提炼出需要解决的几个关键问题点技术点"><a class="markdownIt-Anchor" href="#围绕研究题目提炼出需要解决的几个关键问题点技术点"></a> 围绕研究题目，提炼出需要解决的几个关键问题点/技术点</h3><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><h3 id="总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"><a class="markdownIt-Anchor" href="#总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"></a> 总体解决方案（最好能画一个总体方案图、或有一段描述清楚总体思路）</h3><h3 id="每个问题点技术点分别的解决方案或模型设计"><a class="markdownIt-Anchor" href="#每个问题点技术点分别的解决方案或模型设计"></a> 每个问题点/技术点分别的解决方案或模型设计</h3><h2 id="实验设计结果分析"><a class="markdownIt-Anchor" href="#实验设计结果分析"></a> 实验设计&amp;结果分析</h2><h3 id="场景选择-实验设计-指标选取"><a class="markdownIt-Anchor" href="#场景选择-实验设计-指标选取"></a> 场景选择、实验设计、指标选取</h3><h3 id="实验结果分析"><a class="markdownIt-Anchor" href="#实验结果分析"></a> 实验结果分析</h3><h2 id="论文结论"><a class="markdownIt-Anchor" href="#论文结论"></a> 论文结论</h2><h3 id="得出文章结论"><a class="markdownIt-Anchor" href="#得出文章结论"></a> 得出文章结论</h3><h4 id="为什么librabft不使用门限签名"><a class="markdownIt-Anchor" href="#为什么librabft不使用门限签名"></a> 为什么libraBFT不使用门限签名？</h4><p>目前找到的原因如下：</p><p>LibraBFT 使用<strong>聚合签名</strong>来保留签署仲裁证书的验证者的身份。 这使我们能够为有助于仲裁证书的验证人提供激励，聚合签名也不需要复杂的 密钥 阈值设置。</p><p>libraBFT用的是聚合签名而非门限签名</p><h4 id="聚合签名和门限签名的区别"><a class="markdownIt-Anchor" href="#聚合签名和门限签名的区别"></a> 聚合签名和门限签名的区别：</h4><p>聚合签名：将多个签名聚合成一个</p><p>门限签名：也称多重签名，m of n 门限签名，即系统中共有n个用户，任意m个用户聚在一起可以恢复出secret，任意少于m个用户聚在一起都不能恢复出secret。</p><p>应用在区块链中的聚合签名<br>聚合签名在区块链中主要是用来实现交易的批量验证</p><p>为了方便理解，举个简单的例子：<br>一个区块中包含1000笔交易，每笔交易都对应一个唯一的数字签名</p><p>传统方式：如果想要验证这个区块的正确性，则需要依次验证这1000个签名，验证效率低下；<br>引入聚合签名：如果将聚合签名技术引入：首先将1000个签名聚合成一个签名，仅需要验证最终聚合后的一个签名，验证通过，则证明这个区块没有问题，验证不通过，则说明这1000笔交易中有非法交易。</p><p>聚合签名技术实现的难易程度根据选择的数字签名算法不同，有很大的区别。</p><p>数字签名算法目前较为流行的有：ECDSA、Schnorr、BLS等.<br>根据系统需求，选择。</p><p>应用在区块链中的门限签名<br>根据所读论文，下面简述一下我的理解，可能存在理解偏差，望各位指正。</p><p>个人理解：门限签名技术在区块链中是降低拜占庭类共识算法通信复杂度的一种方式。<br>如PBFT，需要将消息进行两次全网广播，即通信复杂度为平方级别，在进行视图切换时，通信复杂度为立方级别。<br>SBFT（2019）采用了门限签名技术和收集器（collector）技术，将P2P全网广播改为由collector收集消息，collector一定数量的签名后，聚合，再由collector发送聚合后的签名，将消息复杂度降到多项式级别。即，门限签名技术多用于拜占庭容错类算法来降低消息复杂度。2f+1 of 3f+1 门限签名。</p><p>关于门限签名的实现，主要包括密钥的生成分发和签名。密钥的生成和分发，主要涉及数字签名算法的选择和密钥的分发，数字签名如ECDSA、BLS等，密钥分发方式如Shamir Secret Share（shamir秘密分享）、VSS(verifiable secret share)等，关于SSS和VSS，会在以后的文章中介绍。签名阶段，没有什么特殊，依旧是用自己的私钥对消息进行签名即可。<br>————————————————<br>版权声明：本文为CSDN博主「"sudo」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Sanayeah/article/details/115646312">https://blog.csdn.net/Sanayeah/article/details/115646312</a></p><h4 id="还有哪些bft算法运用了门限签名"><a class="markdownIt-Anchor" href="#还有哪些bft算法运用了门限签名"></a> 还有哪些bft算法运用了门限签名？</h4><p>采用聚合签名，然后假定leader是诚实的让leader去收集签名。采用聚合签名的方法其实从Byzcoin就有了，然后其实很多共识算法，不仅限于BFT算法，例如Dfinity，也在采用这类方法。</p><blockquote><p><a href="https://www.8btc.com/article/431321">LibraBFT算法简述</a></p></blockquote><blockquote><p><a href="https://www.chainnode.com/tutorial/4855">详解Libra区块链及其共识协议</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;透过区块链看拜占庭容错共识&lt;/p&gt; 
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;p&gt;​	我们提出了HotStuff，一个基于leader节点的拜占庭问题(Byzantine fault-tolerant replication protocal， BFT)的部分同步(partially synchronous)模型。一旦网络进入同步状态，HotStuff算法将允许一个正确的leader节点以实际（相对于最大）网络延迟的频率（速度）推动协议达成共识依照某个频率（如最大网络延迟）发起共识，这一特性被称为响应性（responsiveness），并且&lt;mark&gt;通信复杂度与复制(replica)数量呈线性关系&lt;/mark&gt;。据我们所知，HotStuff是第一个表现出这些综合特性的部分同步BFT复制协议。HotStuff是围绕着一个新颖的框架建立的，它在经典的BFT基础和区块链之间形成了一个桥梁。它允许其他已知的协议（DLS、PBFT、Tendermint、Casper）和我们的协议在一个共同的框架中表达。&lt;/p&gt;
&lt;p&gt;​	我们在一个有100多个副本的网络上部署HotStuff，实现了与BFT-MaRt相当的吞吐量和延迟，同时在leader故障切换期间拥有线性的网络通信次数（与之相对的，BFTSMaRt算法相同的功能需要使用&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(n^3)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.064108em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;次网络通信）。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;
&lt;p&gt;​	拜占庭容错(Byzantine fault tolerance, BFT)指的是一个计算网络在其副本节点遭遇任意错误（如拜占庭错误）时，如何保证关键的网络操作能够得以执行。在状态机复制（SMR）的背景下[35, 47]，整个系统提供了一个可复制的服务，该服务可以被镜像部署到网络的N个副本中。一个BFT-SMR协议用来保证没有出错的副本能够以统一的顺序执行一系列由客户端提交的指令，即使存在一些拜占庭节点尝试阻止网络达成共识。在一轮共识中，算法保证由n-f个未出错的副本能够独立的执行客户端指令，并产生该指令下相同且唯一的结果。正如常见的那样，我们在这里关注的是部分同步通信模型（Partially Synchronous Communication Model）[25]，即在某个未知的全局稳定时间（Global Stabilazation TimeGST）之后，信息传输的已知约束∆成立。在这个模型中，需要n≥3f+1的非故障复制体以相同的顺序对相同的命令达成一致（例如，[12]），并且只有在GST之后才能确定性地确保进展[27]。&lt;/p&gt;
&lt;p&gt;​	==当BFT SMR协议最初被构想出来时，典型的目标系统规模是n=4或n=7，部署在局域网上。然而，由于拜占庭容错在区块链中的应用，人们对其重新产生了兴趣，现在需要能够扩展到更大n的解决方案。==与无权限区块链（例如支持比特币的区块链）相比，所谓的有权限区块链涉及一组复制体，它们共同维护一个有序的命令分类账，或者说，这些副本支持了网络的SMR特性。&lt;mark&gt;尽管它们具有许可的性质，但设想了数百甚至数千个复制体的数量（例如，[42，30]）。此外，将它们部署到广域网络需要设置∆以适应更高的通信延迟变化。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;​	**拓展性挑战（The scaling challenge）。**自从PBFT[20]（部分同步模型中第一个实用的BFT复制解决方案）问世以来，许多BFT解决方案都是围绕其核心的两阶段范式建立的。其实用性在于，一个稳定的leader节点可以在短短两轮的消息交换中驱动一个共识决定。&lt;mark&gt;第一阶段通过让一个副本获得包含 n−f 个投票的法定人数证书(Quorum Certificate, QC)，进而保证提议的唯一性。第二阶段则保证leader节点可以说服其他副本去向一个安全的提议投票。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;​	为新的leader节点收集信息以及向副本发送提案的过程，称之为视图转换(view change)，是整个网络的核心操作。&lt;mark&gt;不幸的是，基于两阶段范式的视图改变远不是那么简单[38]，容易出错[4]，甚至对于中等规模的系统也会产生巨大的通信费用。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;它要求新的leader从(n - f)个副本中传递信息，每个副本报告自己的最高已知QC。即使只计算认证器（数字签名或消息认证码），在PBFT中，传达一个新提案的通信次数为&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(n^3)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.064108em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个认证器，==该算法的一个变体，通过阈值数字签名(Threshold Digital Signatures)，将多个认证器组合成一个的算法能有效优化耗时，不过即便如此依旧有 O(n2) 的时间复杂度。（例如[18, 30]）==在PBFT中，如果在达成单一共识决定之前，发生&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个视图变化，那么传输的认证器总数为&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(n^4)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.064108em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;(&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;n^3*n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8141079999999999em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;∗&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.43056em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;)，即使有阈值签名也是&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(n^3)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.064108em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。这一扩展挑战不仅困扰着PBFT，也困扰着此后开发的许多其他协议，&lt;mark&gt;例如Prime[9]、Zyzzyva[34]、Upright[22]、BFT-MaRt[13]、700BFT[11]和SBFT[30]&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;​	&lt;mark&gt;HotStuff围绕着一个三阶段的核心，允许新leader简单地挑选它所知道的最高QC。它引入了第二个阶段，允许复制体在该阶段投票后 “改变主意”，根本不需要leader证明。因此同时降低了时间复杂度以及换leader协议的复杂度。最后，在几乎完成所有阶段的共识后，HotStuff能够很简单的并行化，以保证便捷的leader循环。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;​	据我们所知，在区块链领域只有如Tendermint[15, 16]和Casper[17]这样的BFT协议，遵循这样一个简单的leader制度。然而，这些系统是围绕&lt;mark&gt;同步核心&lt;/mark&gt;建立的，其中提案是在预先确定的时间间隔内提出的，必须适应在广域点对点gossip网络上传播信息所需的最坏情况。这样做，他们放弃了大多数实用的BFT-SMR解决方案（包括上面列出的那些）的一个标志，即乐观的响应性[42]。非正式地，响应性要求非故障leader一旦被指定，就能在仅取决于实际消息延迟的时间内推动协议达成共识，与任何已知的消息传输延迟的上限无关[10]。==对我们的模型来说，更合适的是乐观的响应性，它只要求在特殊的（希望是常见的）情况下–这里是在达成GST之后–有响应性。==无论乐观与否，&lt;mark&gt;像Tendermint/Casper这样的设计是不可能有响应性的&lt;/mark&gt;。&lt;mark&gt;问题的关键在于，可能存在一个具有最高质量控制的诚实的副本，但leader并不知道它。我们可以建立这样的场景，使进展卡死&lt;/mark&gt;（详细的无生境场景见第4.4节）。==事实上，如果不能在关键的协议步骤中加入必要的延迟，就会导致完全失去有效性，这在一些现有的部署中已经有所报道，==例如，见[3, 2, 19] 。&lt;/p&gt;
&lt;p&gt;​	**我们的贡献。**据我们所知，我们提出了第一个BFT-SMR协议，称为HotStuff，以实现以下两个特性。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;线性视图变换复杂度&lt;/strong&gt;:在达到GST时限之后，任何正确的leader一旦被指定，只需发送O(n)个副本认证,就可以提出一个公式决策。这包括leader被替换的情况。因此，在大量leader崩溃的最坏情况下，GST之后达成共识的通信成本是O(n2)个认证者。&lt;/p&gt;
&lt;p&gt;​	**乐观的回应性。**在达到GST时限之后，任何正确的leader，一旦被指定，只需要等待前n-f个回应，以保证它能创造一个能取得进展的提案。这包括leader被替换的情况。&lt;/p&gt;
&lt;p&gt;​	&lt;mark&gt;HotStuff的另一个特点是，新的leader推动协议达成共识的成本不高于当前leader节点人的成本。因此，HotStuff支持leader的频繁继任，有人认为这在区块链背景下对确保链的质量很有用[28]。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;​	==HotStuff通过在每个视图中增加一个阶段来实现这些特性，这是以延迟的小代价换取leader替换协议的大大简化。==这种交换只产生了实际的网络延迟，在实践中通常远远小于∆。因此，我们希望这种增加的延迟比以前的协议所产生的延迟要小得多，这些协议放弃了响应性以实现线性的视图更换。此外，由于我们在第5节中介绍的有效管道，吞吐量也不会受到影响。&lt;/p&gt;
&lt;p&gt;​	除了理论上的贡献，HotStuff还提供了对一般BFT复制的理解和实践中的协议实例化的见解（见第6节）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个运行在图上的BFT复现框架。 通过投票和规则提交保障的安全性。 活跃性是通过Pacemaker提供的，支持向图添加新的副本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在该框架下实现已知协议（DLS、PBFT、Tendmint和Casper），以及我们自己的HotStuff协议。&lt;/p&gt;
&lt;p&gt;HotStuff的另一个优点是非常简单，由于其机制本身就是非常经济性的：只包含两种消息的类别，以及一个简单地规则用于决定副本相互之间如何对待。安全性是通过投票和提交规则来保证的，而活跃性则需要&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cnblogs.com/chimeiwangliang/p/7975911.html&quot;&gt;Pacemaker机制&lt;/a&gt;，该机制与安全机制是完全独立的。同时，他允许通过少量的变化实现几种已知的协议(DLS, PBDF, Tendermint和Casper)。这种灵活性来源于其对于图上节点的操作，在现代区块链和传统的BFT基础间架设了一个桥梁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	我们描述了HotStuff的原型实现和初步评估。在一个有一百多个副本的网络上部署，HotStuff实现了与BFT-MaRt等成熟系统相当的吞吐量和延迟，有时甚至超过了BFT-MaRt，其代码复杂度远远超过了HotStuff。我们进一步证明，HotStuff的通信足迹在面对频繁的leader更换时保持不变，而BFT-MaRt则随着复制数量的增加而呈二次方增长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210140901336.png&quot; alt=&quot;image-20221014090155168&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/137667542&quot;&gt;区块链HotStuff共识协议论文翻译-Introduction&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2相关工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2相关工作&quot;&gt;&lt;/a&gt; 2.相关工作&lt;/h2&gt;
&lt;h2 id=&quot;markdown-增加文献引用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#markdown-增加文献引用&quot;&gt;&lt;/a&gt; Markdown 增加文献引用&lt;/h2&gt;
&lt;p&gt;​	Lamport等人[37]将面对拜占庭失败时达成共识的问题表述为拜占庭将军问题，他们还创造了 &quot;拜占庭失败 &quot;一词。第一个同步解决方案是由Pease等人[43]给出的，后来由Dolev和Strong[24]改进。改进后的协议具有&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;O(n^3)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.064108em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.02778em;&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.8141079999999999em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的通信复杂度，Dolev和Reischuk[23]证明这是最佳的。Katz和Koo[32]给出了一个使用随机性的基于leader的同步协议，显示了一个具有(n - 1)/2弹性的预期恒定回合解决方案。&lt;/p&gt;
&lt;p&gt;​	同时，在异步设置中，Fischer等人[27]表明，在异步设置中，面对单个故障，该问题是无法确定解决的。此外，Ben-Or[12]证明了任何异步解决方案的（n - 1）/3弹性约束。设计了两种方法来规避这种不可能性。一个是由Ben[12]提出的基于随机化的做法，使用持续随机的“虚拟硬币”翻转，直到恰好收敛到共识状态。后续的工作使用加密方法来共享一个不可预测的“硬币”，将复杂度降低到可预期的恒定回合，以及复杂度 O(n3) 的通信开销[18]。&lt;/p&gt;
&lt;p&gt;​	第二种方法依赖于部分同步，最早由Dwork, Lynch, and Stockmeyer (DLS) [25]展示。该协议在异步期间保持安全，而在系统变得同步之后，DLS保证终止。一旦保持同步，DLS就会产生O(n4)的总通信量和O(n)的每个决策回合。&lt;/p&gt;
&lt;p&gt;​	状态机复制的核心是依靠共识来安排客户请求的顺序，以便正确的复制体按照这个顺序执行它们。在SMR中反复出现的对共识的需求导致Lamport设计了Paxos[36]，这是一个运行古老管道的协议，其中一个稳定的leader以线性通信和一次往返的方式驱动决策。类似的重点促使Castro和Liskov[20, 21]开发了一个名为PBFT的基于leader的拜占庭SMR协议，其稳定的leader需要O(n2)次通信和每次决策的两次往返，而leader替换协议产生了O(n3)次通信。PBFT已经被部署在几个系统中，包括BFTSMaRt[13]。Kotla等人在名为Zyzzyva[34]的协议中为PBFT引入了一条乐观的线性路径，该协议被用于几个系统中，例如Upright[22]和Byzcoin[33]。乐观的路径具有线性复杂度，而leader替换协议仍然是O（n3）。Abraham等人[4]后来在Zyzzyva中暴露了一个安全漏洞，并提出了xes[5，30]。另一方面，为了同时降低协议本身的复杂性，Song等人提出了Bosco[49]，这是一个简单的单步协议，在乐观路径上具有低延迟，需要5f+1个副本。SBFT[30]引入了一个O(n2)的通信视图改变协议，支持一个稳定的leader协议，具有乐观的线性，一个往返的决定。它通过利用两种方法降低了通信复杂性：Reiter[45]的基于收集器的通信范式，以及Cachin等人[18]通过协议投票的阈值加密法进行签名组合。&lt;/p&gt;
&lt;p&gt;​	状态复制机(SMR)通过其核心的共识机制对客户端请求进行排序，以达到确定性的执行结果。这种SMR反复出现的需求，让Lamport设计出了Paxos协议[36]，该协议提供了一个高效的流水线，在这个流水线上，一个稳定的leader节点可以在一轮通信中，使用线性的通信开销来广播决策。Castro和Liskov[20, 21]也实现了相似的需求，他们提供了一个高效的基于leader节点的拜占庭SMR协议，该协议名字叫做PBFT。在PBFT中，一个稳定的leader节点需要 O(n2) 的通信开销和两轮通信来完成一次决策广播，同时，倘若leader节点需要更替，则需要花费 O(n3) 的通信开销。PBFT被部署在了多个系统中，其中就包括&lt;mark&gt;BFTSMaRt[13]&lt;/mark&gt;。Kotla等研究者则在PBFT基础上，引入了一个乐观的线性路径(optimistic linear path)，并得到了Zyzzyva协议[34]，该协议也被部署在了Upright、Byzcoin等系统中。乐观路径拥有线性的复杂度，但leader节点的更替仍然需要 O(n3) 的时间复杂度。Abraham等人随机表示Zyzzyva协议存在安全漏洞，并提交了修正方案。改修正方案还有效地减小了协议自身的复杂度。Song等人提出了Bosco协议，这是一个建议的单阶段协议，在乐观路径上拥有较低的延迟。该协议要求 5f+1 个副本节点。SBFT协议引入了一个能够在 O(n2) 通信复杂度下，实现view-change的协议，并且支持一个稳定的leader节点实现乐观的线性、单轮决策。协议利用两种方法来降低通信复杂度，Reiter提出的一个机遇收集者(collector)的通信机制，以及Cachin等人提出的通过门限密码(threshold crptography)对协议投票以实现部分签名合并的算法。&lt;/p&gt;
&lt;p&gt;​	Ramasamy等人提出了一个采用随机化的基于leader节点的拜占庭SMR协议[44]，&lt;mark&gt;Miller等人开发了一个名为HoneyBadgerBFT的无leader节点变体[39]。这些随机拜占庭解决方案的核心是采用随机异步拜占庭共识，其最好的已知通信复杂度为O(n3)（见上文），通过分批摊销成本。然而，最近，基于这篇HotStuff论文中的想法，向PODC’19[8]提交的一份并行文件进一步将通信复杂度提高到O(n2)。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;​	比特币的核心是一个被称为中本聪的协议[40]，这是一个同步协议，只有概率性的安全保证，没有真实性（见[28，41，6]中的分析）。它在参与者未知的无许可模式下运行，并通过工作证明保持弹性。如上所述，最近的区块链解决方案以各种方式将工作证明解决方案与经典的BFT解决方案混合起来[26, 33, 7, 17, 29, 31, 42]。这些混合的解决方案中，都需要解决轮流领导的问题，这为HotStuff提供了设计动机。&lt;/p&gt;
&lt;h2 id=&quot;3模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#3模型&quot;&gt;&lt;/a&gt; 3.模型&lt;/h2&gt;
&lt;p&gt;​	我们考虑一个由&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;n=3f+1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.43056em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222222222222222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.64444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;个副本组成的系统，以&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;∈&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;i∈[n]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.69862em;vertical-align:-0.0391em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;∈&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为索引，其中&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&quot;true&quot;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;.&lt;/mi&gt;&lt;mo separator=&quot;true&quot;&gt;,&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;[n]={1, . . . , n}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8388800000000001em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mpunct&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.16666666666666666em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;. 一组&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;⊂&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;F⊂[n]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.72243em;vertical-align:-0.0391em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.13889em;&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;⊂&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的最多&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;∣&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;∣&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;f = |F|&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.8888799999999999em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.10764em;&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot; style=&quot;margin-right:0.13889em;&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;∣&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的复制是拜占庭式的故障，其余的是正确的。我们通常会把拜占庭副本称为由对手协调，对手会了解这些副本所持有的所有内部状态（包括它们的加密密钥，见下文）。&lt;/p&gt;
&lt;p&gt;​	网络通信是点对点的、经过验证的和可靠的：一个正确的复制体从另一个正确的复制体收到一个消息，当且仅当后者向前者发送该消息。当我们提到 &quot;广播 &quot;时，它涉及到广播者，如果正确的话，向所有副本，包括它自己，发送相同的点对点信息。我们采用Dwork等人[25]的部分同步模型，其中有一个已知的边界&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;Δ&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\Delta&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.68333em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;Δ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和一个未知的全球稳定时间（GST），这样在GST之后，两个正确的副本之间的所有传输都在时间∆内到达。我们的协议将始终确保安全，并将保证在GST之后的一定时间内取得进展。(在GST之前保证进度是不可能的[27]。)在实践中，如果系统在GST之后足够长的时间内保持稳定（即，如果消息在∆时间内到达），我们的协议将保证进度，尽管假设它永远这样做是为了简化讨论。&lt;/p&gt;
&lt;p&gt;​	密码学原理。HotStuff使用了阈值签名[48, 18, 14]。在一个(k, n)阈值签名方案中，有一个由所有副本持有的单一公钥，而n个副本中的每一个都持有一个不同的私钥。第i个副本可以使用其私钥对消息m贡献一个部分签名&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;ρ&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;←&lt;/mo&gt;&lt;msub&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;tsign&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\rho_i \leftarrow \operatorname{tsign}_i(m)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.625em;vertical-align:-0.19444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;ρ&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.31166399999999994em;&quot;&gt;&lt;span style=&quot;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.15em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mrel&quot;&gt;←&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2777777777777778em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mop&quot;&gt;&lt;span class=&quot;mop&quot;&gt;&lt;span class=&quot;mord mathrm&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mord mathrm&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mord mathrm&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathrm&quot; style=&quot;margin-right:0.01389em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathrm&quot;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.21752399999999997em;&quot;&gt;&lt;span style=&quot;top:-2.4558600000000004em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.24414em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。部分签名&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mrow&gt;&lt;mo fence=&quot;true&quot;&gt;{&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;ρ&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo fence=&quot;true&quot;&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;∈&lt;/mo&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\left\{\rho_i\right\}_{i \in I}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1.07707em;vertical-align:-0.32706999999999997em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;minner&quot;&gt;&lt;span class=&quot;minner&quot;&gt;&lt;span class=&quot;mopen delimcenter&quot; style=&quot;top:0em;&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;ρ&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.31166399999999994em;&quot;&gt;&lt;span style=&quot;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.15em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;mclose delimcenter&quot; style=&quot;top:0em;&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t vlist-t2&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.17863099999999998em;&quot;&gt;&lt;span style=&quot;top:-2.4003em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mrel mtight&quot;&gt;∈&lt;/span&gt;&lt;span class=&quot;mord mathdefault mtight&quot; style=&quot;margin-right:0.07847em;&quot;&gt;I&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-s&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.32706999999999997em;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，其中|I| = k，每个ρi ← tsigni(m)，可以用来对m产生数字签名σ← tcombine(m, {ρi}i∈I )，任何其他副本可以使用公钥和函数tverify验证该签名。我们要求，如果ρi ← tsigni(m)对于每个i∈I，|I| = k，并且如果σ← tcombine(m, {ρi}i∈I )，那么tverify(m, σ)返回真。然而，考虑到对神谕{tsigni(-)}i∈[n]/F的访问，对手在严格少于k-f的这些神谕上查询tsigni(m)，产生消息m的签名σ的概率可以忽略不计（即，使tverify(m, σ)返回真）。在本文中，我们使用k=2f+1的阈值。同样，我们通常会在协议描述中隐含对tverify的调用。&lt;/p&gt;
&lt;p&gt;​	我们还需要一个加密哈希函数h（也称为消息摘要函数），它将一个任意长度的输入映射到一个固定长度的输出。哈希函数必须是抗碰撞的[46]，这非正式地要求对手产生h(m)=h(m′)的输入m和m′的概率是可以忽略的。因此，h(m)可以作为协议中唯一输入m的识别器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度测量。&lt;/strong&gt; 我们关心的复杂度是认证器复杂度，具体来说就是在所有副本i∈[n]上，副本i在GST后达成共识决定的协议中收到的认证器数量之和。(同样，在GST之前，在最坏的情况下可能根本无法达成共识决定[27]）。这里，一个认证器是一个部分签名或一个签名。认证器复杂度是通信复杂度的一个有用的衡量标准，原因有几个。首先，像比特复杂度，也不像消息复杂度，它隐藏了关于传输拓扑结构的不必要的细节。例如，携带一个认证器的n个消息与携带n个认证器的一个消息计数相同。第二，认证器复杂度比比特复杂度更适合捕捉像我们这样反复达成共识的协议中的成本，其中每个共识决定（或在通往该共识决定的路上提出的每个观点）都由一个单调增加的计数器识别。也就是说，因为这样的计数器是无限增加的，所以发送这样的计数器的协议的位复杂度是不能被约束的。第三，由于在实践中，产生或验证数字签名的加密操作以及产生或结合部分签名的加密操作通常是使用它们的协议中计算最密集的操作，认证器的复杂性也提供了对协议计算负担的洞察力。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;基本hotstuff&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HotStuff解决了状态机复制（SMR）问题。SMR的核心是一个决定客户不断增长的命令请求日志的协议。一组状态机复制体按照顺序一致地应用命令。客户端向所有的复制体发送命令请求，并等待其中（f+1）个复制体的回应。在大多数情况下，我们在讨论中省略了客户端，并将有关客户端请求的编号和去重的问题交给标准文献。&lt;/p&gt;
&lt;p&gt;​	基本HotStuff解决方案在算法2中提出。该协议在一个连续的视图中工作，其编号为单调增加的视图编号。每个viewNumber都有一个唯一的专用leader节点，为所有人所知。每个副本都将一棵悬而未决的命令树作为其本地数据结构。每个树节点都包含一个提议的命令（或一批），与协议相关的元数据，以及一个父级链接。一个给定节点所带领的分支是通过访问父链接从该节点一直到树根的路径。在协议期间，一个单调增长的分支成为承诺。为了成为承诺，提出分支的特定视图的leader必须在准备、预承诺和承诺三个阶段从（n - f ）个副本的法定人数中收集投票。&lt;/p&gt;
&lt;p&gt;​	该协议的一个关键成分是对leader提案的(n - f )票数的集合，被称为法定人数证书（简称 “QC”）。QC与一个特定的节点和一个视图编号相关联。tcombine工具采用了一个阈值签名方案，以产生一个(n - f )签名的投票表示，作为一个单一的认证器。&lt;/p&gt;
&lt;p&gt;​	下面我们将分阶段对协议逻辑进行操作性描述，然后在算法2中进行精确的规范，并以安全性、有效性和复杂性的论证来结束本节。&lt;/p&gt;
&lt;h3 id=&quot;41阶段&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#41阶段&quot;&gt;&lt;/a&gt; 4.1阶段&lt;/h3&gt;
&lt;p&gt;​	准备阶段。新leader的协议从收集（n - f ）个副本的新视图消息开始。新视图消息由一个副本在过渡到viewNumber（包括第一个视图）时发送，并携带该副本收到的最高prepareQC（如果没有，则为⊥），如下所述。&lt;/p&gt;
&lt;p&gt;​	leader节点对这些消息进行处理，以选择一个分支，该分支具有形成prepareQC的最高前视图。leader节点在新视图信息中选择具有最高视图的prepareQC，表示为highQC。因为highQC是(n - f )个副本中最高的，没有更高的视图可以达成提交决定。因此，由highQC.nodeleader节点的分支是安全的。&lt;/p&gt;
&lt;p&gt;​	在职leader可以省略收集新视点信息来选择安全分支，他可以简单地选择自己的最高prepareQC作为highQC。我们将这一优化推迟到第6节，在这一节中只描述一个单一的、不结盟的leader协议。请注意，与类似PBFT的协议不同，在leader协议中包括这一步骤是直接的，而且无论在什么情况下，它都会产生与协议中所有其他阶段相同的线性开销。&lt;/p&gt;
&lt;p&gt;​	leader节点使用createLeaf方法用一个新的提议来扩展highQC.node的尾部。该方法创建一个新的叶子节点作为子节点，并将父节点的摘要嵌入子节点中。然后，leader在准备消息中向所有其他副本发送新节点。为了安全起见，该提议带有高QC。&lt;/p&gt;
&lt;p&gt;​	在收到leader发出的当前视图的准备消息后，副本r使用安全节点谓词来决定是否接受它。如果它被接受，复制体就向leader发送一个带有部分签名（由tsignr产生）的提案的准备投票。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;safeNode谓词&lt;/strong&gt;。safeNode谓词是该协议的一个核心要素。它检查携带QC论证m.justify的提议消息m，并确定m.node是否可以安全接受。接受提议的安全规则是m.node的分支从当前锁定的节点延伸到锁定的QC.node。另一方面，有效性规则是，如果m.justify的视图高于当前锁定的QC .node，复制体将接受m。只要两个规则中的任何一个成立，该谓词就是真的。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;预承诺阶段&lt;/strong&gt;。当leader收到针对当前提案curProposal的(n - f )张准备票时，它将其合并为prepareQC。leader节点在预承诺消息中广播prepareQC。一个副本以预承诺投票的方式回应leader，该预承诺投票具有提案的签名摘要。&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;提交阶段&lt;/strong&gt;。提交阶段与预提交阶段类似。当leader收到(n - f )张预提交投票时，它将这些投票合并成一个precommitQC，并在提交消息中进行广播；复制体以提交投票来回应它。重要的是，在这一点上，一个复制体通过将其锁定的QC设置为precommitQC而被锁定（算法2的第25行）。这对保护提案的安全至关重要，因为它可能成为一个共识决定。&lt;/p&gt;
&lt;p&gt;**决定阶段。**当leader收到(n - f )张提交票时，它将它们合并成一个commitQC。一旦leader集合了一个commitQC，它就会将其作为一个decide消息发送给所有其他的副本。收到决定消息后，复制体认为commitQC中包含的提议是一个承诺的决定，并执行承诺分支中的命令。复制体增加viewNumber并开始下一个视图。&lt;/p&gt;
&lt;p&gt;**nextView的中断。**在所有阶段，副本在视图viewNumber处等待消息，等待的时间由辅助的nextView(viewNumber )工具决定。如果nextView(viewNumber )中断等待，副本也会增加viewNumber并开始下一个视图。&lt;/p&gt;
&lt;h3 id=&quot;42数据结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#42数据结构&quot;&gt;&lt;/a&gt; 4.2数据结构&lt;/h3&gt;
&lt;p&gt;**信息。**协议中的消息m有一组固定的elds，使用算法1中的Msg()工具进行填充。m自动带有curView，即发送者的当前视图编号。每个消息都有一个m.type∈ {new-view, prepare, pre-commit, commit, decide}。m.node包含一个提议节点（提议分支的叶子节点）。有一个可选的eld m.justify。leader节点总是使用这个字段来携带不同阶段的QC。复制体在new-view消息中使用它来携带最高的prepareQC。在副本角色中发送的每条消息都包含一个部分签名m.partialSig，由发送者在〈m.type, m.viewNumber , m.node〉上签名，该签名被添加到voteMsg()工具中。&lt;/p&gt;
&lt;p&gt;**法定人数证书。**一个关于元组〈type, viewNumber , node〉的Quorum Certicate（QC）是一个数据类型，它结合了由（n - f）个副本签署的同一元组的签名集合。给定一个QC qc，我们用qc.type, qc.viewNumber , qc.node来指代原始元组的匹配字段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树和分支&lt;/strong&gt;。每个命令都被包裹在一个节点中，该节点还包含一个父节点链接，该链接可以是父节点的哈希摘要。我们省略了伪代码中的实现细节。在协议中，一个副本只有在节点leader节点的分支已经在其本地树中之后才会传递消息。在实践中，落后的接收者可以通过从其他副本中获取缺失的节点来追赶。为了简洁起见，这些细节也从伪代码中省略了。如果两个分支都不是另一个分支的延伸，那么这两个分支就是相互矛盾的。如果两个节点所leader节点的分支是相互矛盾的，那么这两个节点就是相互矛盾的。&lt;/p&gt;
&lt;p&gt;**簿记变量。**复制体使用额外的本地变量来保存协议状态：(i) viewNumber，最初为1，通过完成决策或下一个View中断而增加；(ii) lock quorum certicate locked QC，最初为⊥，存储复制体投票提交的最高QC；以及(iii) prepareQC，最初为⊥，存储复制体投票预提交的最高QC。此外，为了递增地执行已提交的命令日志，复制体维护其分支已被执行的最高节点。为了简洁起见，下面省略了这一点。&lt;/p&gt;
&lt;h3 id=&quot;43协议规范&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#43协议规范&quot;&gt;&lt;/a&gt; 4.3协议规范&lt;/h3&gt;
&lt;p&gt;​	算法2中给出的协议被描述为一个迭代的逐个视图的循环。在每个视图中，一个复制体根据其角色连续执行各个阶段，描述为连续的 &quot;作为 &quot;块。一个副本可以有一个以上的角色。例如，一个leader也是一个（正常的）副本。角色间的作为块的执行可以同时进行。每个as块的执行都是原子性的。nextView的中断中止了任何as块中的所有操作，并跳转到 &quot;Final &quot;块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210140949044.png&quot; alt=&quot;image-20221014094925966&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210140949230.png&quot; alt=&quot;image-20221014094940152&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210140950785.png&quot; alt=&quot;image-20221014095001709&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210140950152.png&quot; alt=&quot;image-20221014095058109&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210140951177.png&quot; alt=&quot;image-20221014095116123&quot;&gt;&lt;/p&gt;
&lt;p&gt;4.4安全，活性和复杂性&lt;/p&gt;
&lt;p&gt;安全性。我们首先认为，如果tverify(〈qc.type, qc.viewNumber , qc.node〉, qc.sig)为真，则法定人数证书qc为有效。&lt;/p&gt;
&lt;p&gt;推理1。对于任何有效的qc1, qc2，其中qc1.type = qc2.type并且qc1.node与qc2.node冲突，我们有qc1.viewNumber 6= qc2.viewNumber 。&lt;/p&gt;
&lt;p&gt;证明。为了显示矛盾，假设qc1.viewNumber = qc2.viewNumber = v。因为一个有效的QC只能在有n - f = 2f + 1票（即部分签名）的情况下形成，必须有一个正确的复制品在v的同一阶段投票两次。&lt;/p&gt;
&lt;p&gt;定理2. 如果w和b是对立的节点，那么它们不可能同时被承诺，各自被一个正确的副本承诺。&lt;/p&gt;
&lt;p&gt;证明。我们通过矛盾法来证明这一重要定理。让qc1表示一个有效的commitQC（即qc1.type = commit），这样qc1.node = w；qc2表示一个有效的commitQC，这样qc2.node = b。根据定理1，v1 6= v2.假设v1 &amp;lt; v2.&lt;/p&gt;
&lt;p&gt;​	我们现在用vs表示比v1高的最低视图，对于它有一个有效的prepareQC，qcs（即qcs.type = prepare），其中qcs.viewNumber = vs，并且qcs.node与w一致。&lt;/p&gt;
&lt;p&gt;E(prepareQC ) :=(v1 &amp;lt; prepareQC .viewNumber ≤ v2) ∧ (prepareQC .node conicts with w).&lt;/p&gt;
&lt;p&gt;现在我们可以设置第一个开关点qcs。&lt;/p&gt;
&lt;p&gt;qcs := arg min prepare QC {prepareQC .viewNumber | prepareQC is valid ∧ E(prepareQC )} .&lt;/p&gt;
&lt;p&gt;请注意，根据假设，这样的qcs必须存在；例如，qcs可能是在视图v2中形成的prepareQC。&lt;/p&gt;
&lt;p&gt;​	在发送部分结果tsignr(〈qc1.type, qc1.viewNumber , qc1.node〉)的正确副本中，让r成为第一个贡献tsignr(〈qcs.type, qcs.viewNumber , qcs.node〉的副本；这样的r一定存在，因为否则qc1.sig和qcs.sig之一不可能被创建。在视图v1期间，副本r在算法2的第25行将其锁定的QC更新为w上的precommitQC。由于vs的最小化，在qcs形成之前，复制体r在w所带领的分支上的锁没有被改变。否则，r一定看到了其他的prepareQC，而且视图较低，因为第17行在第25行之前，与最小性相矛盾。现在考虑复制体r在视图vs的准备阶段对safeNode的调用，消息m携带m.node = qcs.node。根据假设，m.node与锁定的QC.node相冲突，因此算法1第26行的disjunct为假。此外，m.justify.viewNumber &amp;gt; v1将违反vs的最小化原则，因此算法1第27行的disjunct也是假的。因此，safeNode必须返回false，并且r不能对视图vs中的矛盾分支投准备票，这是一个矛盾。&lt;/p&gt;
&lt;p&gt;​	有效性。在上一节中，有两个函数没有提到：leader和nextView。它们的命名不会影响到协议的安全性，但它们确实关系到有效性。在给出它们的候选名称之前，我们首先表明，在GST之后，有一个有约束的持续时间Tf，如果在Tf期间所有正确的复制都留在视图v中，并且视图v的leader是正确的，那么就会达成一个决定。下面我们说，如果qc1和qc2是有效的，qc1.node = qc2.node，并且qc1.viewNumber = qc2.viewNumber，则qc1和qc2是匹配的。&lt;/p&gt;
&lt;p&gt;​	推理3. 如果一个正确的副本被锁定，使得锁定的QC=预提交的QC，那么至少有f+1个正确的副本投票给一些与锁定的QC匹配的prepareQC。&lt;/p&gt;
&lt;p&gt;​	证明。假设副本r被锁定在precommitQC上。那么，在准备阶段（算法2的第10行），有（n-f）票投给了匹配的prepareQC，其中至少有f+1票是来自正确的副本。&lt;/p&gt;
&lt;p&gt;​	定理4. 在GST之后，存在一个有界的时间段Tf，如果在Tf期间所有正确的复制都留在视图v中，并且视图v的leader是正确的，那么就会达成一个决定。&lt;/p&gt;
&lt;p&gt;​	证明。从一个新视图开始，leader收集(n - f )个新视图消息，并在广播prepare messsage之前计算它的highQC。假设在所有的副本中（包括leader本身），保持最高的锁是锁定的QC = precommitQC ∗。根据定理3，我们知道至少有f+1个正确的副本投票选出了与precommitQC ∗相匹配的prepareQC，并且已经在他们的new-view消息中把它们发送给了leader。因此，leader必须在这些新视图消息中至少有一个学到匹配的prepareQC ∗，并在其prepare消息中使用它作为highQC。根据假设，所有正确的副本在他们的视图中都是同步的，并且leader是无故障的。因此，所有正确的复制体都会在准备阶段投票，因为在safeNode中，算法1第27行的条件是满足的（即使消息中的节点与复制体的陈旧锁定的QC.节点相冲突，因此第26行不是）。然后，在leader为这个视图组装了一个有效的prepareQC之后，所有的副本将在接下来的所有阶段进行投票，导致一个新的决定。在GST之后，这些阶段完成的持续时间Tf是有边界的长度。&lt;/p&gt;
&lt;p&gt;​	该协议是乐观响应的，因为没有明确的 &quot;等待-∆&quot;步骤，而且safeNode中的逻辑分离被用来在三阶段范式的帮助下覆盖一个过时的锁。&lt;/p&gt;
&lt;p&gt;​	我们现在为leader和nextView提供了简单的结构，以确保在GST之后，最终会达到一个视图，其中leader是正确的，所有正确的副本在Tf时间内保持在这个视图中。对于leader来说，它成功地返回了一些从视图编号到副本的确定性映射，最终在所有的副本中轮换。nextView的一个可能的解决方案是利用一个保持超时时间间隔的指数型退避机制。然后在进入每个视图时设置一个定时器。当定时器熄灭而没有做出任何决定时，复制体将间隔时间加倍，并调用nextView来推进视图。由于每次的时间间隔都会翻倍，所有正确的副本的等待时间间隔最终会有至少Tf的共同重叠，在此期间，leader可以驱动一个决定。&lt;/p&gt;
&lt;p&gt;​	**两相的无生气。**我们现在展示了一个 &quot;两阶段 &quot;HotStuff的先天非决定性情景。这解释了在Casper和Tendermint中引入同步延迟的必要性，因此也解释了放弃（乐观的）响应性的必要性。&lt;/p&gt;
&lt;p&gt;​	在两阶段的HotStuff变体中，我们省略预提交阶段，直接进行提交。当一个副本在prepareQC上投票时，它就会被锁定。假设在视图v中，一个leader提出了b。它完成了准备阶段，一些副本rv对prepareQC进行了投票，比如qc，使得qc.node = b。一个异步的网络调度导致其余的副本在没有收到qc的情况下移动到视图v+1。&lt;/p&gt;
&lt;p&gt;​	我们现在无休止地重复下面的单视图记录。我们从视图v+1开始，只有rv持有系统中最高的prepareQC（即qc）。新的leaderl从2f + 1个副本中收集新的视图信息，不包括rv。其中最高的prepareQC，qc′，拥有视图v-1，b′=qc′.节点与b冲突。然后，l提出了扩展b′的b′，2个诚实的复制体以投票方式回应，但是rv拒绝了它，因为它被锁在qc上，b′与b冲突，而且qc′比qc低。最终，有2个复制体放弃了，转到了下一个视图。就在这时，一个有问题的副本回应了我的提议，然后我提出了一个prepareQC（v+1，b′′），一个副本，比如说rv+1，投票给它，并锁定在它上面。&lt;/p&gt;
&lt;p&gt;​	复杂性。在HotStuff的每个阶段，只有leader向所有副本进行广播，而副本则以部分签名的方式回应发送者一次，以证明投票。在leader的信息中，QC由之前收集的(n - f )票数证明组成，它可以由一个阈值签名来编码。在一个副本的回应中，来自该副本的部分签名是唯一的认证者。因此，在每个阶段，总共有O(n)个认证器被收到。由于阶段的数量是恒定的，每个视图的总体复杂度是O(n)。&lt;/p&gt;
&lt;p&gt;5.链式的hotstuff&lt;/p&gt;
&lt;p&gt;​	一个基本的HotStuffleader需要三个阶段来提交一个提案。这些阶段除了从副本中收集投票外，并不做 &quot;有用 &quot;的工作，而且它们都非常相似。在Chained HotStuff中，我们改进了Basic HotStuff协议的实用性，同时也大大简化了它。我们的想法是在每个准备阶段改变视图，因此每个提案都有自己的视图。这就减少了消息类型的数量，并允许对决策进行流水线处理。在Casper[1]中提出了一个类似的减少消息类型的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141021023.png&quot; alt=&quot;image-20221014102135968&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141021759.png&quot; alt=&quot;image-20221014102144728&quot;&gt;&lt;/p&gt;
&lt;p&gt;图1：链式HotStuff是一种流水线式的基本HotStuff，其中一个QC可以同时服务于不同阶段。&lt;/p&gt;
&lt;p&gt;图2：视图v4、v5、v6的节点形成了一个三链。视图v8的节点在Chained HotStuff中不构成有效的One-Chain（但在第6节的算法中放松后，它是一个有效的One-Chain）。&lt;/p&gt;
&lt;p&gt;​	更具体地说，在Chained HotStuff中，准备阶段的投票被leader收集到一个通用的QC中。然后，genericQC被转发给下一个视图的leader，本质上是将下一个阶段的责任委托给下一个leader，而这个阶段本来是预提交的。然而，下一个leader实际上并没有进行预承诺阶段，而是启动了一个新的准备阶段并增加了自己的提议。视图v+1的准备阶段同时作为视图v的预提交阶段。视图v+2的准备阶段同时作为视图v+1的预提交阶段和视图v的提交阶段。&lt;/p&gt;
&lt;p&gt;​	图1描述了嵌入链式HotStuff提案链中的基本HotStuff协议阶段的流水线。Chained HotStuff的视图v1、v2、v3作为v1中提议的cmd1的准备、预提交和提交基本HotStuff阶段，该命令在v4结束时被提交。 视图v2、v3、v4作为v2中提议的cmd2的三个基本HotStuff阶段，它在v5结束时被提交。 这些阶段产生的其他提议以类似方式继续管道，并以虚线框表示。在图1中，单箭头表示节点b的b.parenteld，双箭头表示b.justify.node。&lt;/p&gt;
&lt;p&gt;​	因此，在Chained HotStuff中只有两种类型的消息，一种是新视图消息，一种是通用阶段通用消息。通用QC在所有的逻辑流水线阶段都有作用。接下来，我们将解释管道中的机制，以照顾锁定和提交，这只发生在Basic HotStuff的提交和决定阶段。&lt;/p&gt;
&lt;p&gt;​	虚设节点。某个视图viewNumber中的leader节点所使用的通用QC可能不会直接引用前一个视图（viewNumber-1）的提议。原因是前一个视图的leader节点未能获得QC，要么是因为有相互矛盾的提议，要么是因为良性崩溃。为了简化树形结构，createLeaf用空白节点扩展了genericQC .node，直到提议视图的高度（节点分支上的父链接数），因此视图编号等同于节点高度。因此，嵌入节点b中的QC可能并不指它的父节点，也就是说，b.justify.node可能不等于b.parent（图2中的最后一个节点）。&lt;/p&gt;
&lt;p&gt;​	一链、二链和三链。当一个节点b∗携带一个指向直接父节点的QC，即b∗.justify.node = b∗.parent，我们就说它形成了一个One-Chain。用b′′＝b∗.justify.node表示。如果节点b∗除了形成一个一链之外，b′′.justify.node = b′′.parent，则形成一个二链。如果b′′形成一个二链，它就形成一个三链。&lt;/p&gt;
&lt;p&gt;​	看一下链b = b′.justify.node, b′ = b′′.justify.node, b′′ = b∗.justify.node，祖先的差距可能发生在任何一个节点。这些情况类似于Basic HotStuff的leader未能完成三个阶段中的任何一个，被nextView打断到下一个视图。&lt;/p&gt;
&lt;p&gt;​	如果b∗形成了一个单链，那么b′′的准备阶段就成功了。因此，当一个副本为b∗投票时，它应该记住genericQC ← b∗.justify。我们注意到，即使在One-Chain不直接的情况下，更新genericQC也是安全的，只要它比当前的genericQC高。在第6节描述的实现代码中，我们确实在这种情况下更新了genericQC。&lt;/p&gt;
&lt;p&gt;​	如果b∗形成了一个双链，那么b′的预提交阶段就成功了。因此，副本应该更新锁定的QC← b′′.justify。我们再次指出，即使在二链不直接的情况下，锁也可以被更新–安全不会被破坏–事实上，这在第6节的实现代码中已经给出。&lt;/p&gt;
&lt;p&gt;​	最后，如果b∗形成了一个三链，那么b的提交阶段就成功了，b就成了一个承诺的决策。&lt;/p&gt;
&lt;p&gt;​	算法3显示了链式HotStuff的伪代码。附录A中的定理5所给出的安全性证明与Basic HotStuff的类似。我们要求有效节点中的QC指的是其祖先。为简洁起见，我们假设该约束总是成立，并在代码中省略检查。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141040289.png&quot; alt=&quot;image-20221014104034227&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;6实施&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#6实施&quot;&gt;&lt;/a&gt; 6.实施&lt;/h2&gt;
&lt;p&gt;​	HotStuff是一个实用的协议，用于构建古老的SMR系统。由于其简单性，我们可以很容易地将算法3变成一个事件驱动式的规范，它几乎就像一个原型实现的代码骨架。&lt;/p&gt;
&lt;p&gt;​	如算法4所示，该代码被进一步简化和泛化，从本体中提取出有效性机制，放入一个名为Pacemaker的模块。在通用阶段结束时，下一个leader总是等待一个通用的QC，然后开始它的统治，而不是把这个逻辑委托给Pacemaker。一个稳定的leader可以跳过这个步骤，在多个高度上精简提案。&lt;/p&gt;
&lt;p&gt;​	此外，我们放宽了保持最高通用QC和锁定QC的直接父约束，同时仍然保留了有效节点中的QC总是指其祖先的要求。正确性的证明与Chained HotStuff相似，我们也将其推迟到[50]的附录中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141042299.png&quot; alt=&quot;image-20221014104232261&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	它还保持一个常数b0，即所有正确的副本都知道的同一个创世节点。为了引导，b0包含了一个硬编码的QC，block、bexec、bleaf都被初始化为b0，qchigh包含b0的QC。&lt;/p&gt;
&lt;p&gt;​	起搏器。起搏器是一种保证在GST之后取得进展的机制。它通过两种成分实现这一目标。&lt;/p&gt;
&lt;p&gt;​	第一种是 “同步化”，将所有正确的复制体和唯一的leader带到一个共同的高度，并保持足够长的时间。文献[25, 20, 15]中通常的同步机制是让复制体增加它们在更大高度上花费的∆的数量，直到取得进展。确定性地选举leader的一个常见方法是使用轮流leader方案，其中所有正确的副本保持预先设定的leader时间表，并在leader被降级时轮流到下一个。&lt;/p&gt;
&lt;p&gt;​	其次，起搏器需要为leader提供一种方法来选择一个将被正确的副本所支持的提议。如算法5所示，在视图改变后，在onReceiveNewView中，新的leader通过onNextSyncView收集复制体发送的新视图消息，以发现最高的QC，满足onReceiveProposal中第二部分条件的有效性（算法4的第18行）。然而，在同一视图中，现任leader节点将把新节点链到自己最后提议的叶子的末端，这里不需要新视图消息。基于一些应用特有的启发式方法（例如，等到之前提议的节点获得QC），现任leader会调用onBeat来提议一个携带命令的新节点来执行。&lt;/p&gt;
&lt;p&gt;​	值得注意的是，即使一个坏的起搏器任意调用onPropose，或者任性地选择一个父类和一个QC，并且在任何调度延迟的情况下，安全性总是得到保证的。因此，仅由算法4保证的安全性与算法5的任何潜在实例化的有效性完全脱钩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141044708.png&quot; alt=&quot;image-20221014104403646&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141044496.png&quot; alt=&quot;image-20221014104416453&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141044313.png&quot; alt=&quot;image-20221014104424276&quot;&gt;&lt;/p&gt;
&lt;p&gt;两阶段的HotStuff变体。为了进一步证明HotStuff框架的灵活性，算法6显示了HotStuff的两阶段变体。只有更新程序受到影响，达成提交决定需要双链，而单链则决定锁。如上所述（第4.4节），这种两阶段变体失去了优化响应性，与Tendermint/Casper类似。它的好处是阶段更少，同时可以通过在Pacemaker中加入一个基于最大网络延迟的等待来解决失效性问题。进一步的讨论见第7.3节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141044789.png&quot; alt=&quot;image-20221014104447742&quot;&gt;&lt;/p&gt;
&lt;p&gt;7.单链和双链&lt;/p&gt;
&lt;p&gt;​	在本节中，我们研究了横跨拜占庭容错领域四十年研究的四种BFT复制协议，将它们投射到类似于Chained HotStuff的连锁框架中。&lt;/p&gt;
&lt;p&gt;​	图3提供了我们所考虑的ve协议的提交规则的鸟瞰图，包括HotStuff。&lt;/p&gt;
&lt;p&gt;​	简而言之，DLS[25]中的提交规则是一链式的，只允许一个节点被自己的leader提交。PBFT[20]、Tendermint[15, 16]和Casper[17]的提交规则几乎相同，都是双链的。它们的不同之处在于它们引入的有效性机制，PBFT有二次大小的leader “证明”（没有线性），Tendermint和Casper在每个leader提议之前引入一个强制性的∆延迟（没有优化响应性）。HotStuff使用三链规则，并且有一个没有延迟的线性leader协议。&lt;/p&gt;
&lt;p&gt;7.1DLS&lt;/p&gt;
&lt;p&gt;​	最简单的提交规则是一链式的。这个规则以Dwork, Lynch, and Stockmeyer (DLS)为模型，是第一个已知的异步拜占庭共识解决方案，如图3（a）所示。一个副本在DLS中被锁定在它投票支持的最高节点上。&lt;/p&gt;
&lt;p&gt;​	不幸的是，如果在某个高度，一个leader含糊其辞，而两个正确的复制品在该高度被锁定在相互矛盾的提案上，那么这个规则将很容易导致僵局。放弃任何一个锁都是不安全的，除非有2f+1表示他们没有投票给锁定的值。&lt;/p&gt;
&lt;p&gt;​	事实上，在 DLS 中，只有每个高度的leader自己可以通过一链式提交规则达成提交决定。因此，只有leader本身在犹豫不决的情况下才会受到伤害。如果2f+1个副本没有投票支持，或者有相互矛盾的提议（由leader签署），那么副本可以放弃一个锁。在DLS的每个高度结束时发生的解锁协议被证明是相当复杂和昂贵的。再加上一个事实，即只有一个高度的leader可以决定，在最好的情况下，没有故障发生，网络是及时的，DLS需要n个leader轮换，以及O(n4)消息传输，每一个决定。虽然它在展示一个安全的异步协议方面有了新的突破，但DLS并不是作为一个实用的解决方案而设计的。&lt;/p&gt;
&lt;p&gt;7.2pbft&lt;/p&gt;
&lt;p&gt;​	以PBFT为模型，一个更实用的Appraoch使用双链提交规则，见图3（b）。当一个副本投票给一个形成一链的节点时，它就被锁定在该节点上。由于每个节点都有一个QC，所以在同一高度上的相互矛盾的One-Chain是不可能的，因此可以避免DLS的死锁情况。&lt;/p&gt;
&lt;p&gt;​	然而，如果一个副本拥有比其他副本更高的锁，即使leader收集了n-f个副本的信息，也可能不知道它的情况。这可能会阻止leader无休止地达成决定，纯粹是由于调度的原因。为了得到 “解锁”，PBFT通过携带由2f+1个副本组成的最高一链的证明来解锁所有副本。这个证明是相当复杂的，如下所述。&lt;/p&gt;
&lt;p&gt;​	原始的PBFT已经开源[20]，并在一些后续工作中采用[13, 34]，leader证明包含一组从n-f个副本中收集的信息，报告每个成员投票支持的最高一链。每个One-Chain都包含一个QC，因此总的通信成本是O(n3)。利用来自[45, 18]的签名组合方法，SBFT[30]通过将每个QC变成一个单一的值，将这个成本降低到O(n2)。&lt;/p&gt;
&lt;p&gt;​	在[21]中的PBFT变体中，leader证明只包含leader从法定人数中收集到的最高一链一次。它还包括法定人数中每个成员的一个签名值，证明它没有投票给更高的一链。广播这个证明会产生通信复杂度O(n2)。请注意，虽然QC上的签名可以合并成一个单一的值，但整个证明不能减少到恒定的大小，因为来自法定人数中不同成员的消息可能有不同的值。&lt;/p&gt;
&lt;p&gt;​	在这两个变体中，一个正确的复制品即使比leader的证明具有更高的一链，也会被解锁。因此，一个正确的leader可以在同步期间强制接受其提议，并且保证了有效性。每个leader的替换成本是二次通信。&lt;/p&gt;
&lt;p&gt;7.3 Tendermint和Casper&lt;/p&gt;
&lt;p&gt;​	Tendermint有一个与PBFT相同的双链提交规则，而Casper有一个双链规则，其中叶子不需要有QC来指导父本。也就是说，在Casper中，图3（c,d）分别描述了Tendermint和Casper的提交规则。&lt;/p&gt;
&lt;p&gt;​	在这两种方法中，leader只需将它所知道的最高的One-Chain与它的提议一起发送。如果一个副本从leader那里收到更高的一链，它就会解锁一链。&lt;/p&gt;
&lt;p&gt;​	然而，由于正确的副本可能不会为leader的节点投票，为了保证进展，新的leader必须通过等待最大的网络延迟来获得最高的One-Chain。否则，如果leader只等待前n-f个信息来开始一个新的高度，就没有进展保证。leader延迟在Tendermint和Casper中都是固有的，目的是为了提供灵活性。&lt;/p&gt;
&lt;p&gt;​	这个简单的leader协议体现了leader协议的通信复杂性的线性飞跃，HotStuff借用了这个协议。正如上面已经提到的，QC可以通过使用阈值签名来捕获一个单一的值，因此leader可以以线性通信复杂度收集和传播最高的One-Chain。然而，至关重要的是，由于额外的QC步骤，HotStuff不要求leader等待最大的网络延迟。&lt;/p&gt;
&lt;p&gt;8.评价&lt;/p&gt;
&lt;p&gt;我们将HotStuff作为一个库来实现，大约有4K行的C++代码。最明显的是，伪代码中规定的核心共识逻辑只消耗了大约200行。在这一节中，我们将首先通过与最先进的系统BFT-MaRt[13]的比较来检查基线吞吐量和延迟。然后，我们将关注视图变化的消息成本，以了解我们在这种情况下的优势。&lt;/p&gt;
&lt;p&gt;8.1 设置&lt;/p&gt;
&lt;p&gt;​	我们在亚马逊EC2上使用c5.4xlarge实例进行了实验。每个实例有16个vCPU，由英特尔至强白金8000处理器支持。所有核心的CPU时钟速度都达到了3.4GHz。我们在单个虚拟机实例上运行每个副本，因此大量使用线程的BFT-MaRt被允许利用每个副本的16个核心，就像他们最初的评估[13]一样。iperf测量的最大TCP带宽约为每秒1.2千兆字节。我们在任何运行中都没有对带宽进行节制。两台机器之间的网络延迟小于1毫秒。&lt;/p&gt;
&lt;p&gt;​	我们的HotStuff原型实现在投票和法定人数证书中都使用secp256k1作为所有数字签名。BFT-MaRt在正常运行期间对消息中的MAC（消息验证码）使用hmac-sha1，在视图变化期间除了MAC之外还使用数字签名。&lt;/p&gt;
&lt;p&gt;​	HotStuff的所有结果都反映了客户端的端到端测量。对于BFT-MaRt，我们使用了BFT-MaRt网站（&lt;a href=&quot;https://github.com/bft-smart/library%EF%BC%89%E4%B8%8A%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E7%A8%8B%E5%BA%8FToughputLatencyServer%E5%92%8CToughputLatencyClient%E3%80%82%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A8%8B%E5%BA%8F%E6%B5%8B%E9%87%8F%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E5%BB%B6%E8%BF%9F%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%B5%8B%E9%87%8F%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%8C%E8%80%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%97%B6%E6%B5%8B%E9%87%8F%E5%90%9E%E5%90%90%E9%87%8F%E5%92%8C%E5%BB%B6%E8%BF%9F%E3%80%82%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E4%BA%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F%E7%BB%93%E6%9E%9C%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%BB%B6%E6%97%B6%E7%BB%93%E6%9E%9C%E3%80%82&quot;&gt;https://github.com/bft-smart/library）上的微基准程序ToughputLatencyServer和ToughputLatencyClient。客户端程序测量端到端的延迟，但不测量吞吐量，而服务器端程序同时测量吞吐量和延迟。我们使用了服务器的吞吐量结果和客户端的延时结果。&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;82-基础性能&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#82-基础性能&quot;&gt;&lt;/a&gt; 8.2 基础性能&lt;/h3&gt;
&lt;p&gt;​	我们首先测量了其他BFT复制系统评估中常见的吞吐量和延时。我们在一个能容忍单一故障的集合中运行4个副本，即f=1，同时改变操作请求率直到系统饱和。这个基准使用了空的（零大小）操作请求和响应，并且没有触发视图变化；我们在下面扩展到其他设置。虽然我们的响应式HotStuff是三阶段的，但我们也运行其两阶段的变体作为额外的基线，因为BFT-MaRt基线只有两个阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141443179.png&quot; alt=&quot;image-20221014144311135&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4：不同的批处理规模选择下的吞吐量与延迟，4个副本，0/0有效载荷。&lt;/p&gt;
&lt;p&gt;图5：在不同的有效载荷大小选择下，吞吐量与延迟的关系，4个副本，批次大小为400。&lt;/p&gt;
&lt;p&gt;​	图4描述了两个系统的三种批处理规模：100、400和800，不过由于这些系统有不同的批处理方案，这些数字对每个系统的意义略有不同。BFT-MaRt为每个操作驱动一个单独的共识决策，并对来自多个共识协议的消息进行批处理。因此，它有一个典型的L型延迟/吞吐量性能曲线。HotStuff在每个节点批处理多个操作，并以这种方式减轻了每个决策的数字签名成本。然而，每批操作超过400次，批处理所产生的延迟就会高于加密的成本。尽管存在这些差异，三相（“HS3-”）和两相（“HS2-”）HotStuff在所有三种批处理规模下都取得了与BFT-MaRt（“BS-”）相当的延迟性能，而其最大吞吐量明显优于BFT-MaRt。&lt;/p&gt;
&lt;p&gt;​	对于100和400的批处理量，最低延迟的HotStuff点提供的延迟和吞吐量优于BFT-MaRT在其最高吞吐量下可同时实现的延迟和吞吐量，同时会产生少量的延迟增加。这种增加部分是由于HotStuff采用的批处理策略。它需要另外三个完整的批处理（在两阶段的变体中是两个）来达成对一个批次的决定。我们的实验保持了较高的未决请求数量，但批处理规模越大，批处理管道所需的时间就越长。实际部署可以进一步优化，以使批处理规模适应未完成操作的数量。&lt;/p&gt;
&lt;p&gt;图5描述了0/0、128/128和1024/1024三种客户端请求/回复的有效载荷大小（以字节为单位），分别表示为 “p0”、&quot;p128 &quot;和 “p1024”。在所有的有效载荷大小中，三相和两相HotStuff的吞吐量都超过了BFTSMaRt，而延迟相似或相当。&lt;/p&gt;
&lt;p&gt;​	注意BFT-MaRt使用基于对称加密的MAC，比HotStuff使用的数字签名中的非对称加密快几个数量级，而且与BFT-MaRt使用的两相PBFT变体相比，三相HotStuff的往返次数更多。 但HotStuff仍然能够实现可比的延迟和高得多的吞吐量。下面我们将在更具挑战性的情况下评估这两个系统，HotStuff的性能优势将变得更加明显。&lt;/p&gt;
&lt;p&gt;8.3 可扩展性&lt;/p&gt;
&lt;p&gt;​	为了评估HotStuff在不同维度上的可扩展性，我们进行了三个实验。对于基线，我们使用零尺寸的请求/响应有效载荷，同时改变副本的数量。第二次评估用128字节和1024字节的请求/响应有效载荷重复基线实验。第三项测试重复了基线（空的有效载荷），同时引入了副本之间的网络延迟，这些网络延迟均匀分布在5ms±0.5ms或10ms±1.0ms，用NetEm实现（见https://www.linux.org/docs/man8/tc-netem.html）。对于每个数据点，我们用相同的设置重复运行了多次，并显示了误差条以表示所有运行的标准偏差。&lt;/p&gt;
&lt;p&gt;​	图6a（吞吐量）和图6b（延迟）中描述了第一种设置。三相和两相HotStuff都显示出持续优于BFT-MaRt的吞吐量，而它们的延迟仍可与具有优雅降级的BFTSMaRt相比。当n&amp;lt;32时，性能的扩展性比BFT-MaRt好。这是因为我们目前仍然使用secp256k1签名列表来进行QC。在未来，我们计划通过使用快速阈值签名方案来减少HotStuff的加密计算开销。&lt;/p&gt;
&lt;p&gt;​	图7a（吞吐量）和图7b（延迟）中用 &quot;p128 &quot;或 &quot;p1024 &quot;表示有效载荷大小为128或1024字节的第二个设置。由于其二次带宽成本，对于合理的大（1024字节）有效载荷大小，BFT-SMaRt的吞吐量比HotStuff差。&lt;/p&gt;
&lt;p&gt;​	第三种设置在图8a（吞吐量）和图8b（延迟）中显示为 &quot;5ms &quot;或 “10ms”。同样，由于BFT-MaRt中通信的使用量较大，HotStuff在这两种情况下的表现始终优于BFT-MaRt。&lt;/p&gt;
&lt;p&gt;8.4 视图变化&lt;/p&gt;
&lt;p&gt;​	为了评估leader替换的通信复杂性，我们计算了在BFT-MaRt的视图变化协议中进行的MAC或签名验证的数量。我们的评估策略如下。我们在BFT-MaRt中每隔一千次决策就注入一次视图变化。我们对BFT-MaRt的源代码进行了检测&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141447544.png&quot; alt=&quot;image-20221014144707468&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141447457.png&quot; alt=&quot;image-20221014144716411&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141447786.png&quot; alt=&quot;image-20221014144727731&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	代码来计算接收和处理视图变化协议中的信息时的验证次数。除了通信复杂性之外，这种测量还强调了与传输这些验证值相关的加密计算负荷。&lt;/p&gt;
&lt;p&gt;​	图9a和图9b显示了每次视图变化所处理的额外验证器（分别为MAC和签名）的数量，其中 &quot;额外 &quot;被认为是那些如果leader节点保持稳定就不会发送的验证器。请注意，HotStuff没有 &quot;额外 &quot;的认证器，因为无论leader是否保持不变，认证器的数量都是一样的。这两张图显示，BFT-MaRt使用了立方数的MAC和二次数的签名。HotStuff不需要额外的认证器来改变视图，所以从图中省略了。&lt;/p&gt;
&lt;p&gt;​	评估leader替换的实时性能是很棘手的。首先，BFT-MaRt在触发频繁的视图变化时卡住了；我们的认证器计数基准必须在系统卡住之前尽可能多地对成功的视图变化进行平均，重复实验多次。第二，leader替换的实际耗时高度依赖于超时参数和leader选举机制。因此，不可能提供一个有意义的比较。&lt;/p&gt;
&lt;p&gt;9 结论&lt;/p&gt;
&lt;p&gt;​	自从PBFT–部分同步模型中第一个实用的BFT复制解决方案问世以来，许多BFT解决方案都是围绕其核心的两阶段范式建立的。第一阶段通过QC保证提案的唯一性。第二阶段保证新的leader能够说服复制体投票支持一个安全的提案。这需要leader从(n-f)个副本中传递信息，每个副本报告自己的最高QC或投票。一代又一代的两阶段工作因此在leader更换时遭遇了二次通信瓶颈。&lt;/p&gt;
&lt;p&gt;​	HotStuff围绕着一个三阶段的核心，允许新的leader简单地挑选它所知道的最高QC。这减轻了上述复杂性，同时也大大简化了leader替换协议。在（几乎）规范了各个阶段之后，HotStuff的流水线就非常容易了，而且可以经常轮换leader节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/josephucas/pcc-beed/raw/master/img/202210141448697.png&quot; alt=&quot;image-20221014144845632&quot;&gt;&lt;/p&gt;
&lt;p&gt;附录&lt;/p&gt;
&lt;p&gt;链式HotStuff的安全证明&lt;/p&gt;
&lt;p&gt;定理5。让b和w是两个对立的节点。那么它们不能同时被一个诚实的副本承诺。证明。我们通过矛盾法来证明这个定理。通过类似于Lemma 1的论证，b和w必须在不同的视图中。假设在一个ectuion中，b通过QC三链b, b′, b′′, b∗在某个诚实的副本中被承诺，同样地，w通过QC三链w, w′, w′′, w∗在某个诚实的副本中被承诺。由于b, b′, b′′, w, w′, w′′中的每一个都得到了它的QC，那么，我们假设b是在比w′′高的视图中创建的，即b′.justify.viewNumber &amp;gt; w∗.justify.viewNumber ，如图11所示。现在我们用vs表示高于vw′′=w∗.justify.viewNumber的最低视图，其中有一个qcs，使qcs.node与w相冲突。形式上，我们对任何qc下达以下谓语。&lt;/p&gt;
&lt;p&gt;​	E(qc) :=(vw′′ &amp;lt; qc.viewNumber ≤ vb) ∧ (qc.node conicts with w) 。我们现在可以设置第一个切换点qcs：qcs := arg min qc {qc.viewNumber | qc is valid ∧ E(qc)}。&lt;/p&gt;
&lt;p&gt;​	根据假设，这样的qcs存在，例如，qcs可以是b′.justify。让r表示w∗.justify和qcs的交集中的一个正确副本。根据qcs最小化的假设，在qcs形成之前，r对w的锁不会被改变。现在考虑r在视图vs中调用safeNode，消息m携带一个有争议的节点m.node = qcs.node。根据假设，锁的条件（算法1的第26行）是假的。另一方面，该协议要求t = m.node.justify.node是qcs.node的祖先。根据qcs的最小性，m.node.justify.viewNumber≤vw′′。由于qcs.node与w冲突，t不能是w、w′或w′′。那么，m.node.justify.viewNumber &amp;lt; w′.justify.viewNumber ，所以另一半的disjunct也是假的。因此，r不会投票给qcs.node，与r的假设相矛盾。&lt;/p&gt;
&lt;p&gt;​	有效性论证几乎与Basic HotStuff相同，只是我们必须假设在GST之后，连续两个leader节点是正确的，以保证决策。为了简洁起见，我们省略了这一点。&lt;/p&gt;
&lt;p&gt;B 实施的安全证明&lt;/p&gt;
&lt;p&gt;伪码 6. 假设b和w是两个相互矛盾的节点，使得b.height = w.height，那么它们就不能同时拥有有效的法定人数证书。证明。假设他们可以，那么b和w都得到了2f+1票，其中至少有f+1个诚实的副本为每个节点投票，那么一定有一个诚实的副本为两个节点投票，这是不可能的，因为b和w的高度是一样的。符号1. 对于任何节点b，让&quot;←&quot;表示父关系，即b.parent ← b.让&quot;∗ ←&quot;表示祖先关系，即父关系的反演闭合。那么，两个节点b，w是矛盾的，如果b ∗ ←w∧w ∗ ← b。让&quot;⇐&quot;表示QC所指的节点，即b.justify.node ⇐ b。让b和w是两个相互矛盾的节点。那么它们不可能同时被一个诚实的复制品承诺。证明。我们通过矛盾法来证明这个重要的定理。让b和w是两个处于不同高度的冲突节点。假设在执行过程中，b通过QC三链b(⇐ ∧ ← )b′(⇐ ∧ ←)b′′ ⇐ b∗在某个诚实的副本中成为承诺。同样地，通过QC三链w(⇐ ∧ ← )w′(⇐ ∧ ←)w′ ⇐ w∗，w在某个诚实的副本中成为承诺。根据定理1，由于每个节点b, b′, b′′, w, w′, w′′都有QC，那么，我们假设b.height &amp;gt; w′′.height，如图11所示。现在我们用qcs来表示高度小于w′′.height的节点的QC，该节点与w相冲突。E(qc) := (w′′.height &amp;lt; qc.node.height ≤ b.height) ∧ (qc.node conicts with w) 我们现在可以设置第一个转换点qcs: qcs := arg min qc {qc.node.height | qc is valid ∧ E(qc)}。根据假设，这样的qcs存在，例如，qcs可以是b′.justify。让r表示w∗.justify和qcs相交处的一个正确副本。根据qcs最小化的假设，在qcs形成之前，r对w的锁不会被改变。现在考虑对onReceiveProposal的调用，该消息携带一个有争议的节点bnew，这样bnew=qcs.node。根据假设，锁的条件（算法4的第17行）是假的。另一方面，协议要求t = bnew .justify.node是bnew的祖先。 根据qcs的最小性，t.高度≤w′′.高度。由于qcs.node与w相冲突，t不能是w、w′或w′′。那么，t.height&amp;lt;w.height，所以另一半的disjunct也是假的。因此，r不会投票给bnew，与r的假设相矛盾。 定理8。假设cmd 1和cmd 2是任意两个命令，其中cmd 1在cmd 2之前被某个诚实的副本执行，那么任何执行cmd 2的诚实副本都必须在cmd 2之前执行cmd 1。证明。用w表示携带cmd1的节点，b携带cmd2的节点。从Lemma 6可以看出，承诺的节点处于不同的高度。在不丧失一般性的情况下，假设w.height&amp;lt;b.height。w和b的提交是由更新中的onCommit(w′)和onCommit(b′)触发的，其中w ∗ ← w′，b ∗ ← b′。根据Lemma 7，w′一定不会与b′冲突，所以w不会与b冲突。然后w ∗ ← b，当任何诚实的副本执行b时，它一定会通过onCommit的递归逻辑首先执行w。&lt;/p&gt;
&lt;p&gt;B.1 备注 为了深入了解HotStuff设计中的权衡，我们解释了为什么某些约束对于安全是必要的。&lt;/p&gt;
&lt;p&gt;为什么是单调的vheight？假设我们改变投票规则，使副本不需要单调地投票，只要它不对每个高度投票超过一次。削弱后的约束会破坏安全性。例如，一个副本可以先为b投票，然后为w投票。在了解b′，b′′之前，它首先交付w′，w′′，假设锁在w上，并为w′′投票。当它最终交付b′′时，它将ip到bleader节点的分支，因为它有资格被锁定，而且b比w高。最后，副本也将投票给b′′，导致w和b的提交。直接父约束被用来确保证明中使用的等价物b.height&amp;gt;w′′.height，在Lemma 6的帮助下。假设我们不执行提交规则，所以提交约束被弱化为w ∗ ← w′ ∗ ← w′，而不是w ← w′ ← w′（对b也一样）。考虑一下w′.height &amp;lt; b.height &amp;lt; b′.height &amp;lt; w′′.height &amp;lt; b′′.height的情况。有可能，一个副本可以先投票给w′′，然后发现b′′，切换到b的分支，但这已经太晚了，因为w可能已经提交了。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;/h2&gt;
&lt;h2 id=&quot;关键词&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关键词&quot;&gt;&lt;/a&gt; 关键词&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Trust Model to Minimize the Influence of Malicious Attacks in Sharding Based Blockchain Networks</title>
    <link href="http://example.com/2022/06/08/Trust-Model-to-Minimize-the-Influence-of-Malicious-Attacks-in-Sharding-Based-Blockchain-Networks/"/>
    <id>http://example.com/2022/06/08/Trust-Model-to-Minimize-the-Influence-of-Malicious-Attacks-in-Sharding-Based-Blockchain-Networks/</id>
    <published>2022-06-08T08:12:35.000Z</published>
    <updated>2022-09-28T01:46:13.335Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><h2 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h2><span id="more"></span><h2 id="研究问题"><a class="markdownIt-Anchor" href="#研究问题"></a> 研究问题</h2><h3 id="研究背景简要介绍"><a class="markdownIt-Anchor" href="#研究背景简要介绍"></a> 研究背景(简要介绍)</h3><h3 id="研究问题或解决技术问题描述需定位和描述清晰"><a class="markdownIt-Anchor" href="#研究问题或解决技术问题描述需定位和描述清晰"></a> 研究问题或解决技术问题描述（需定位和描述清晰）</h3><h2 id="研究现状"><a class="markdownIt-Anchor" href="#研究现状"></a> 研究现状</h2><h3 id="围绕研究问题进行相关研究成果列举注明参考文献"><a class="markdownIt-Anchor" href="#围绕研究问题进行相关研究成果列举注明参考文献"></a> 围绕研究问题，进行相关研究成果列举（注明参考文献）</h3><h3 id="研究现状总结及现有研究仍然存在不足或问题"><a class="markdownIt-Anchor" href="#研究现状总结及现有研究仍然存在不足或问题"></a> 研究现状总结，及现有研究仍然存在不足或问题</h3><h2 id="思路特色"><a class="markdownIt-Anchor" href="#思路特色"></a> 思路特色</h2><h3 id="与现有研究技术手段不同之处"><a class="markdownIt-Anchor" href="#与现有研究技术手段不同之处"></a> 与现有研究（技术手段）不同之处</h3><h2 id="关键问题技术点"><a class="markdownIt-Anchor" href="#关键问题技术点"></a> 关键问题/技术点</h2><h3 id="围绕研究题目提炼出需要解决的几个关键问题点技术点"><a class="markdownIt-Anchor" href="#围绕研究题目提炼出需要解决的几个关键问题点技术点"></a> 围绕研究题目，提炼出需要解决的几个关键问题点/技术点</h3><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><h3 id="总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"><a class="markdownIt-Anchor" href="#总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"></a> 总体解决方案（最好能画一个总体方案图、或有一段描述清楚总体思路）</h3><h3 id="每个问题点技术点分别的解决方案或模型设计"><a class="markdownIt-Anchor" href="#每个问题点技术点分别的解决方案或模型设计"></a> 每个问题点/技术点分别的解决方案或模型设计</h3><h2 id="实验设计结果分析"><a class="markdownIt-Anchor" href="#实验设计结果分析"></a> 实验设计&amp;结果分析</h2><h3 id="场景选择-实验设计-指标选取"><a class="markdownIt-Anchor" href="#场景选择-实验设计-指标选取"></a> 场景选择、实验设计、指标选取</h3><h3 id="实验结果分析"><a class="markdownIt-Anchor" href="#实验结果分析"></a> 实验结果分析</h3><h2 id="论文结论"><a class="markdownIt-Anchor" href="#论文结论"></a> 论文结论</h2><h3 id="得出文章结论"><a class="markdownIt-Anchor" href="#得出文章结论"></a> 得出文章结论</h3>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt; 
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;/h2&gt;
&lt;h2 id=&quot;关键词&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关键词&quot;&gt;&lt;/a&gt; 关键词&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Information-Centric Massive IoT-Based Ubiquitous Connected VR/AR in 6G: A Proposed Caching Consensus Approach</title>
    <link href="http://example.com/2022/06/07/Information-Centric-Massive-IoT-Based-Ubiquitous-Connected-VR-AR-in-6G-A-Proposed-Caching-Consensus-Approach/"/>
    <id>http://example.com/2022/06/07/Information-Centric-Massive-IoT-Based-Ubiquitous-Connected-VR-AR-in-6G-A-Proposed-Caching-Consensus-Approach/</id>
    <published>2022-06-07T08:52:44.000Z</published>
    <updated>2022-09-28T01:46:13.332Z</updated>
    
    <content type="html"><![CDATA[<p align="right">在6G中以信息为中心的随处连接VR/AR的大规模物联网：一种拟议的缓存共识方法</p> <h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>现有的 海量物联网的发展不仅带来了丰富的硬件资源，也带来了数据管理难、资源运行难、效率低等问题。</p><p>6G网络可以解决 不仅可以提供更快的数据传输速率，更多的设备连接，还可以带来无处不在的虚拟现实/增强现实（VR/AR）服务。在6G时代，大规模的物联网设备将产生VR/AR服务和资源需求，网络也将面临前所未有的压力来应对无处不在的VR/AR需求。</p><p>针对上述问题</p><ol><li>提出了适合6G大规模VR/AR内容分发的以信息为中心的大规模物联网（IC-MIoT），以提高IC-MIoT的效率，充分保障用户的服务质量（QoS）。<ol><li>介绍了IC-MIoT节点的区块链，并提出了一种新的共识机制Proof-of-Cache-Offloading（PoCO）。</li><li>提出了一个使用区块链支持的IC-MIoT用于VR/AR的架构。大量的物联网资源被充分整合和调度，以支持大规模的VR/AR应用和IC-MIoT。</li><li>为支持区块链的缓存卸载制定了Stackelberg博弈模型和缓存索引选择和计算算法。分析和性能模拟结果表明了所提方案的优越性和有效性。</li></ol></li></ol><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><h2 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h2><p>6G, blockchain, information-centric network (ICN), massive IoT.</p><span id="more"></span><h2 id="期刊类型和水平"><a class="markdownIt-Anchor" href="#期刊类型和水平"></a> 期刊类型和水平</h2><p>IEEE Internet of Things Journal这应该是一个一区的好文章</p><p>一般能够在2～3个月时间获得一审结果并完成返修</p><h2 id="研究问题"><a class="markdownIt-Anchor" href="#研究问题"></a> 研究问题</h2><h3 id="研究背景简要介绍"><a class="markdownIt-Anchor" href="#研究背景简要介绍"></a> 研究背景(简要介绍)</h3><p>介绍了6g，</p><h3 id="研究问题或解决技术问题描述需定位和描述清晰"><a class="markdownIt-Anchor" href="#研究问题或解决技术问题描述需定位和描述清晰"></a> 研究问题或解决技术问题描述（需定位和描述清晰）</h3><p>区块链主要用于保证6G场景下各种交易的安全性和可追溯性。同时，将过去形成的智能合约存储在区块链中，保证ICN路由器之间的安全稳定运行。</p><h2 id="研究现状"><a class="markdownIt-Anchor" href="#研究现状"></a> 研究现状</h2><h3 id="围绕研究问题进行相关研究成果列举注明参考文献"><a class="markdownIt-Anchor" href="#围绕研究问题进行相关研究成果列举注明参考文献"></a> 围绕研究问题，进行相关研究成果列举（注明参考文献）</h3><p>区块链作为一种新兴的分布式架构也在6G中被讨论。在6G中使用区块链的机会和挑战以及克服这些挑战的可能方向在[15]中被讨论。Hewa等人[16]探讨了区块链在6G中应对艰巨挑战的作用、未来的应用机会和潜在的研究方向。</p><p>Chen等人[23]提出了一种信誉管理机制，在车联网的ICN中结合负面和正面交易记录。Sharma等人[24]专注于使用无人机作为随需应变的节点，为支持移动边缘计算的无人机网络提供高效的缓存。</p><h3 id="研究现状总结及现有研究仍然存在不足或问题"><a class="markdownIt-Anchor" href="#研究现状总结及现有研究仍然存在不足或问题"></a> 研究现状总结，及现有研究仍然存在不足或问题</h3><p>虽然大规模物联网中的ICN和区块链的相关研究已经被广泛研究，但很少有作品关注将区块链应用于6G的内容共享，尤其是支持泛在VR/AR的方法。</p><h2 id="思路特色"><a class="markdownIt-Anchor" href="#思路特色"></a> 思路特色</h2><h3 id="与现有研究技术手段不同之处"><a class="markdownIt-Anchor" href="#与现有研究技术手段不同之处"></a> 与现有研究（技术手段）不同之处</h3><p>因此，与现有工作相比，本文的优势在于以下几点。首先，我们提出了6G中的VR/AR内容分发架构，以满足6G网络和大规模物联网的要求。第二，为了保证这个分布式系统的安全稳定运行，我们引入了区块链，并将IC-MIoT的特点与缓存卸载任务相结合。第三，我们充分考虑了我们提出的机制和算法在支持6G的大规模物联网中的可行性和具体操作细节。</p><h2 id="关键问题技术点"><a class="markdownIt-Anchor" href="#关键问题技术点"></a> 关键问题/技术点</h2><h3 id="围绕研究题目提炼出需要解决的几个关键问题点技术点"><a class="markdownIt-Anchor" href="#围绕研究题目提炼出需要解决的几个关键问题点技术点"></a> 围绕研究题目，提炼出需要解决的几个关键问题点/技术点</h3><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><h3 id="总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"><a class="markdownIt-Anchor" href="#总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"></a> 总体解决方案（最好能画一个总体方案图、或有一段描述清楚总体思路）</h3><h3 id="每个问题点技术点分别的解决方案或模型设计"><a class="markdownIt-Anchor" href="#每个问题点技术点分别的解决方案或模型设计"></a> 每个问题点/技术点分别的解决方案或模型设计</h3><h2 id="实验设计结果分析"><a class="markdownIt-Anchor" href="#实验设计结果分析"></a> 实验设计&amp;结果分析</h2><h3 id="场景选择-实验设计-指标选取"><a class="markdownIt-Anchor" href="#场景选择-实验设计-指标选取"></a> 场景选择、实验设计、指标选取</h3><h3 id="实验结果分析"><a class="markdownIt-Anchor" href="#实验结果分析"></a> 实验结果分析</h3><h2 id="论文结论"><a class="markdownIt-Anchor" href="#论文结论"></a> 论文结论</h2><h3 id="得出文章结论"><a class="markdownIt-Anchor" href="#得出文章结论"></a> 得出文章结论</h3>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;在6G中以信息为中心的随处连接VR/AR的大规模物联网：一种拟议的缓存共识方法&lt;/p&gt; 
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;p&gt;现有的 海量物联网的发展不仅带来了丰富的硬件资源，也带来了数据管理难、资源运行难、效率低等问题。&lt;/p&gt;
&lt;p&gt;6G网络可以解决 不仅可以提供更快的数据传输速率，更多的设备连接，还可以带来无处不在的虚拟现实/增强现实（VR/AR）服务。在6G时代，大规模的物联网设备将产生VR/AR服务和资源需求，网络也将面临前所未有的压力来应对无处不在的VR/AR需求。&lt;/p&gt;
&lt;p&gt;针对上述问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提出了适合6G大规模VR/AR内容分发的以信息为中心的大规模物联网（IC-MIoT），以提高IC-MIoT的效率，充分保障用户的服务质量（QoS）。
&lt;ol&gt;
&lt;li&gt;介绍了IC-MIoT节点的区块链，并提出了一种新的共识机制Proof-of-Cache-Offloading（PoCO）。&lt;/li&gt;
&lt;li&gt;提出了一个使用区块链支持的IC-MIoT用于VR/AR的架构。大量的物联网资源被充分整合和调度，以支持大规模的VR/AR应用和IC-MIoT。&lt;/li&gt;
&lt;li&gt;为支持区块链的缓存卸载制定了Stackelberg博弈模型和缓存索引选择和计算算法。分析和性能模拟结果表明了所提方案的优越性和有效性。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;/h2&gt;
&lt;h2 id=&quot;关键词&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关键词&quot;&gt;&lt;/a&gt; 关键词&lt;/h2&gt;
&lt;p&gt;6G, blockchain, information-centric network (ICN), massive IoT.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Reputation-Based Sharding Consensus Model in Information-Centric Networking</title>
    <link href="http://example.com/2022/04/12/Reputation-Based-Sharding-Consensus-Model-in-Information-Centric-Networking/"/>
    <id>http://example.com/2022/04/12/Reputation-Based-Sharding-Consensus-Model-in-Information-Centric-Networking/</id>
    <published>2022-04-12T08:56:02.000Z</published>
    <updated>2022-09-28T01:46:13.334Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><h2 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h2><p>区块链； 信息中心网络；分片；声誉；共识；</p><span id="more"></span><h2 id="研究问题"><a class="markdownIt-Anchor" href="#研究问题"></a> 研究问题</h2><h3 id="研究背景简要介绍"><a class="markdownIt-Anchor" href="#研究背景简要介绍"></a> 研究背景(简要介绍)</h3><p>​介绍区块链技术和信息中心网络的集成，讲述区块链存在的交易效率的问题和现有的解决方法，其中重点介绍了几种分片机制和现有分片机制的问题，</p><h3 id="研究问题或解决技术问题描述需定位和描述清晰"><a class="markdownIt-Anchor" href="#研究问题或解决技术问题描述需定位和描述清晰"></a> 研究问题或解决技术问题描述（需定位和描述清晰）</h3><p>​这篇文章结合SEANet网络可以提供的优势特征如节点之间存在信息交互的特性、网内AE模块的计算能力以及确定性时延解析服务（可以提供分布式、现场的、服务时延保障的ID-NA解析服务）进行建模仿真，基于网内节点对网络贡献度指标（如转发次数、丢包率、命中次数）等角度提取声誉信息，提出了一种多维声誉模型来提高区块链节点的可信度。</p><p>​信誉值由信任参数计算，包括服务质量（QoS）、安全质量（QoSec）、评估信誉、过去信誉和推荐信誉。多维度的声誉值利用客观信任、主观信任和历史信任的角度衡量声誉价值，保证了高声誉价值不能通过欺骗获得，任何新节点都无法通过在短时间内表现良好而显著提高声誉价值。</p><p>​避免了现有声誉评价中由于只考虑区块交易中的行为、对社区的贡献、评论维度的主观评价而带来的合谋或垄断等安全风险。此外，还提出了一种基于网络拓扑的分片划分方案来优化分片组的共识传输过程，以减少共识验证时延。该分片方案通过信誉值和网络距离计算出的总相似度参数，可以实现分片之间的信誉和网络距离的均匀分布。同时，我们也引入名称解析系统为分片的注册和查询提供优势，帮助快速有效地分发交易等事务。</p><h2 id="研究现状"><a class="markdownIt-Anchor" href="#研究现状"></a> 研究现状</h2><h3 id="围绕研究问题进行相关研究成果列举注明参考文献"><a class="markdownIt-Anchor" href="#围绕研究问题进行相关研究成果列举注明参考文献"></a> 围绕研究问题，进行相关研究成果列举（注明参考文献）</h3><p>​对于目前区块链中六种最著名和最典型的分片机制，即Monoxide[101], Elastico[93], OmniLedger[94], Rapidchain[95], Chainspace[102], 和Ethereum 2.0[103]，分片方案大都是基于随机性的，即定期重新洗牌一致共识节点，随机分组以确保系统的安全性。</p><p>​随机方案要满足良好的随机性，即需要满足几个重要的属性，不偏置性、不可预测性和公共可验证性。目前提出的抗偏差的分布随机性方案主要有以下几种：（1）基于PoW的随机方案。在弹性节点中，每个节点在PoW哈希中竞争以获得其身份，然后所有节点被随机分配到不同的碎片[104] (2) RandHound和RandHerd[105]。通过在(t，n)阈值安全模型中提供抗偏差的公共随机性，该模型已经在阈值密码学[106]、[107]和拜占庭共识协议[108]中广泛使用。（3）Algorand [109]。提出了一种基于委员会的共识协议，该协议使用可验证的随机函数(VRF)[110]，以委员会成员的账户余额（即股份），以私人和非互动的方式进行加权。然而，这些都不容易实现。产生公众的随机性是困难的，因为积极的对手可能会不诚实地使公众的随机选择偏向他们的优势。</p><p>​研究者们开始引入了基于信任的分片分配算法，以便根据节点的信任分数在分片之间分配节点。在分片和领导人选举过程中使用的信任分数可以将恶意攻击的对手影响降至最低。[113] 提出了一个信任模型，该模型通过统计共识过程中每个节点同行评审的汇总结果来评估信誉。[114] 介绍了一种新的信誉方案，利用了一个分层的链结构来分别记录交易和声誉。通过一个单独的声誉链更新每个节点的声誉。声誉方案是基于每个节点对共识过程所作贡献中的有效工作。为了确保分片子链的安全，[115,116]增加了声誉评估维度，该维度基于对等方客户的可信度，即与同一分片中的对等方关联的客户，而不仅仅是对共识过程的评估。同时，新的分片聚类方法也受到了研究人员的关注。[117]使用自适应对冲算法[100]进行分片组选择。它是一种决策论在线学习方法，根据最佳策略最小化共识节点的累积损失。[99]基于遗传算法（GA）设计了基于信任的分片分布（TBSD）模型，为分片分布的优化问题提供了足够好的解决方案。基于改进的遗传算法计算最优分片分布，通过探索各种解空间快速找到近似解。[98]提出了一种基于K-Means算法的地理邻近感知聚类（GPSC）方法，以降低构建整个网络拓扑的复杂性，该方法基于著名的K-Means算法将一致性节点分为多个分片簇。这些分片分配方案在一定程度上优化了简单随机分配方法的安全性和效率，但仍然忽略了节点间的异构性。在不考虑节点间服务质量的情况下，对节点的评价信誉进行聚合。这些能力较差的共识节点可能会成为瓶颈，阻碍系统吞吐量。</p><h3 id="研究现状总结及现有研究仍然存在不足或问题"><a class="markdownIt-Anchor" href="#研究现状总结及现有研究仍然存在不足或问题"></a> 研究现状总结，及现有研究仍然存在不足或问题</h3><p>现有的解决方案不能使区块链像所需要的那样扩展到数百或成千上万的参与者[111]。如果没有良好的随机性，区块链系统的安全性就会被破坏。即使有良好的随机性，区块链系统也可能很容易受到破坏。例如，通过一个复杂的攻击，如贿赂攻击[112]，对手可能有能力控制整体计算能力的临时多数（例如，超过50%），这反过来可能会破坏整个系统。</p><h2 id="思路特色"><a class="markdownIt-Anchor" href="#思路特色"></a> 思路特色</h2><h3 id="与现有研究技术手段不同之处"><a class="markdownIt-Anchor" href="#与现有研究技术手段不同之处"></a> 与现有研究（技术手段）不同之处</h3><p>​基于上述调查结果，我们提出本文基于声誉的分片共识模型，并利用亲和传播（AP）算法将共识节点聚集到分片中。考虑到最小的犯错动机和对验证安全性的可量化信心，客户可以在保证安全性的情况下实现实时处理速度的需求。在下一小节我们将对我们的具体方案进行详细描述。</p><h2 id="关键问题技术点"><a class="markdownIt-Anchor" href="#关键问题技术点"></a> 关键问题/技术点</h2><h3 id="围绕研究题目提炼出需要解决的几个关键问题点技术点"><a class="markdownIt-Anchor" href="#围绕研究题目提炼出需要解决的几个关键问题点技术点"></a> 围绕研究题目，提炼出需要解决的几个关键问题点/技术点</h3><p>本研究点的主要贡献如下：</p><p>（1） 我们提出了一种新的多因素信任模型用于一致性共识中的共识参与节点的信誉评估。这些评估参数将从客观信任、主观信任和历史信任的角度衡量声誉价值，从而将恶意节点通过合谋和欺骗改善声誉的概率降至最低。</p><p>（2） 分片分配方案通过亲和传播算法（Affinity Propagation，AP）进行优化。设计新的余弦相似度输入的计算方法。聚类结果很好地考虑了分片内网络距离的减小。所有分片集群在网络中均匀分布，而不是聚集在一个域中。同时，我们的模型还最小化了恶意节点在分片之间的分布，以提高基于分片的区块链的安全性。</p><p>（3） 用OMNET++进行了实验分析。仿真结果表明，我们的声誉方案的估计声誉值与真实声誉值之间的归一化均方误差（NMSE）小于0.02，这证明了我们的声誉评估机制的可靠性。同时，在1000个节点的大型联盟区块链网络的情况下，TPS性能可以达到经典分片OmniLedger方案的1.4倍。</p><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><h3 id="总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"><a class="markdownIt-Anchor" href="#总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"></a> 总体解决方案（最好能画一个总体方案图、或有一段描述清楚总体思路）</h3><p>我们给出了基于声誉的分片模型的架构设计，对关键组件的实现方法进行了定义，并详细描述了模型的安全性和合理性。系统模型如图3.2所示。关键组件包括三个部分：声誉统计、导出和分发分片节点的分组结果、查找用于并行处理事务的可用分片。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/image-20220424165757562.png" alt="image-20220424165757562"></p><h3 id="每个问题点技术点分别的解决方案或模型设计"><a class="markdownIt-Anchor" href="#每个问题点技术点分别的解决方案或模型设计"></a> 每个问题点/技术点分别的解决方案或模型设计</h3><h4 id="声誉机制"><a class="markdownIt-Anchor" href="#声誉机制"></a> 声誉机制</h4><p>​声誉统计：声誉数据可以通过网络边缘计算进行收集、处理和验证，由网内的分布式算力提供一个分布式的信任管理系统支持，该系统监控共识节点的行为，以管理和计算声誉值。边缘数据的聚合可以通过SDN技术来实现，为分片的计算提供有效参数。</p><p>​分片机制增加了区块链网络的可扩展性，但也增加了恶意攻击的影响。为了解决这个问题，研究人员引入了共识节点的信任模型来提高分片和选举过程的安全性。然而，现有研究中的信任模型多基于节点在区块交易中的行为、对社区的贡献、评论等来计算声誉价值。这些维度基于区块链中其他节点的主观评价，而没有考虑网络层共识节点的网络特征。合谋攻击或垄断攻击等安全风险的存在使得这些方案无法提供足够的信任。</p><p>​因此，我们设计了声誉评分的多因素信任模型，该模型将信任参数扩展到服务质量（QoS）、安全质量（QoSec）、评估信誉、过去信誉和推荐信誉。这些评估因素将从客观信任、主观信任和历史信任的角度衡量声誉价值，如图3.3所示。我们的模型保证了两个重要问题，即声誉价值的积累需要一定的时间，而高声誉值不能通过欺骗获得。任何新节点都无法通过在短时间内表现良好而显著提高声誉值。同时，如果可信共识验证节点被检测为行为不端，它将失去系统中的所有声誉积累值，其身份将被列入黑名单。所有其之前验证的交易都将被重新检查，恶意行为的成本非常昂贵，因此保证可信验证节点在任何情况下都没有不当行为的动机。</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/image-20220424170924047.png" alt="image-20220424170924047"></p><p>导出和分发分片节点的分组结果：通过SDN技术获取分片计算的声誉参数和网络距离参数，进行聚类参数和聚类算法的计算，从而得到维持公平分片分布的最优分片聚类集并完成结果的分发</p><p>查找用于并行处理事务的可用分片：分片注册、解析和交易承诺如图3.2的步骤1-3所示。共识阶段中的每个分片的消息广播主节点在本地SNR中使用其ID-NA注册。当事务验证请求提交给客户端节点时，它们从SNR请求最近分片的主节点的网络NA地址，以找到最近的可用分片集。</p><h2 id="实验设计结果分析"><a class="markdownIt-Anchor" href="#实验设计结果分析"></a> 实验设计&amp;结果分析</h2><h3 id="场景选择-实验设计-指标选取"><a class="markdownIt-Anchor" href="#场景选择-实验设计-指标选取"></a> 场景选择、实验设计、指标选取</h3><p>​数据安全：考虑到数据传输和存储的安全性，使用加密技术（如RSA、ECC）对重要信息和消息进行加密和签名。本文不讨论安全方案数据。默认情况下，数据的传输和存储不能被篡改。</p><p>​共识协议：在每个分片内部使用的共识协议是PBFT（实用拜占庭容错）。同时，我们参考了文献[76]中提出的可信性证明（Proof-of-Believability，PoB）的方法。该协议将每个分片内部中的所有共识验证节点分为两组，即可信共识组和普通共识组。可信验证组在第一阶段快速处理事务。之后，普通验证组在第二阶段对交易进行采样和验证，以更高的安全性。节点被选入可信共识组的概率由可信度分数决定，在我们模型中的可信度分数即是声誉分数值。</p><p>​跨分片交易：如上所述，我们在本研究点中不关注跨分片交易。文献[118-122]中提出的跨分片交易方案可与本方案进行结合</p><h3 id="实验结果分析"><a class="markdownIt-Anchor" href="#实验结果分析"></a> 实验结果分析</h3><h2 id="论文结论"><a class="markdownIt-Anchor" href="#论文结论"></a> 论文结论</h2><h3 id="得出文章结论"><a class="markdownIt-Anchor" href="#得出文章结论"></a> 得出文章结论</h3><p>一般般吧，优点是在icn网络中有了声誉机制</p><p>缺点是</p><ol><li>没有介绍这种声誉机制中的声誉值是怎么计算的，只是用了别人已有的声誉值</li><li>这里面介绍的ap分片算法的计算复杂度过高，在工业实践方面根本就没有可行性</li><li>这里面的声誉机制的互通本来就有一个bug那就是存在一个独立的声誉评测机构</li></ol>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt; 
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;/h2&gt;
&lt;h2 id=&quot;关键词&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关键词&quot;&gt;&lt;/a&gt; 关键词&lt;/h2&gt;
&lt;p&gt;区块链； 信息中心网络；分片；声誉；共识；&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>raft学习</title>
    <link href="http://example.com/2022/04/01/raft%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/04/01/raft%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-04-01T07:33:53.000Z</published>
    <updated>2022-09-28T01:46:13.338Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>线性代数&amp;矩阵论学习</title>
    <link href="http://example.com/2022/03/25/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/03/25/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E8%AE%BA%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-25T02:29:59.000Z</published>
    <updated>2022-10-12T08:13:36.145Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <span id="more"></span><p><strong>行列式的绝对值是体积</strong></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/30443024">行列式就是体积/面积？——（一）</a></p><p><a href="https://zhuanlan.zhihu.com/p/29758947">行列式就是体积/面积？——（二）</a></p><p><a href="https://zhuanlan.zhihu.com/p/30534139">行列式就是体积/面积？——（三）</a></p></blockquote><p>也可以作为线性变换的放大率，或者说线性变换的伸缩因子</p><blockquote><p><a href="https://www.zhihu.com/question/36966326/answer/70687817">https://www.zhihu.com/question/36966326/answer/70687817</a></p></blockquote><p>矩阵的行列式就是向量的外积在高维空间上的直接推广</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/108686955">向量外积的直接证明与直观解释，并以此证明正弦公式</a></p></blockquote><p>作者：匿名用户<br>链接：<a href="https://www.zhihu.com/question/26294660/answer/32525286">https://www.zhihu.com/question/26294660/answer/32525286</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>关于行列式，我知道三种等价定义：</p><p>一是用排列和逆序数定义（国内大多数教材上都用这种定义）；</p><p>二是用归一化（单位矩阵行列式为1）、多线性（当矩阵的某一列所有元素都扩大c倍时，相应行列式也扩大c倍。多的意思是对所有n个列都呈现线性性质）、反对称（交换两列行列式反号）来定义；</p><p>三是利用<a href="https://www.zhihu.com/search?q=%E4%BB%A3%E6%95%B0%E4%BD%99%E5%AD%90%E5%BC%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%2232525286%22%7D">代数余子式</a>和按第一行展开进行归纳定义；</p><p>我最喜欢的是第二个定义。行列式等于它的各个列对应的向量张成的平行2n面体的体积，这是因为<strong>行列式是一个交替多重线性形式，而我们通常理解的欧式空间中的体积也是这样一个函数</strong>（单位立方体体积为1，沿某条边扩大c倍体积就扩大c倍，交换两条边以后体积反号——这一条是补充定义的，我们认为体积是有向体积，其数值表示体积大小，正负号表示各条边的排列顺序或坐标轴手性），而<strong>满足归一性、多线性、反对称性的函数是唯一的，所以行列式的直观理解就是欧式空间中的有向体积。</strong></p><p>用矩阵与线性变换的同构来解释也很好理解，**<mark>行列式就是矩阵对应的线性变换对空间的拉伸程度的度量，或者说物体经过变换前后的体积比。</mark>**特别地，如果矩阵不是满秩的，意味着一个<img src="https://www.zhihu.com/equation?tex=n" alt="[公式]">维的空间变换后被压扁了，变成了其中的一个<img src="https://www.zhihu.com/equation?tex=n-1" alt="[公式]">维的<a href="https://www.zhihu.com/search?q=%E8%B6%85%E5%B9%B3%E9%9D%A2&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%2232525286%22%7D">超平面</a>甚至是维度更低的超直线，所以原来空间中的体积元在变换后体积为0，此时行列式也是0。<a href="https://www.zhihu.com/search?q=%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%2232525286%22%7D">多元函数积分</a>作变量代换后要乘一个Jacobi行列式就是这个道理，表示变换前后的微元体积比。</p><p>在矩阵乘法中的左乘和右乘的区别</p><p>左乘的数可以作为是一种基的变化，而右乘可以作为是变换的对象或者是一种逆变换</p><p>逆矩阵相当于线性变换中的逆操作</p><p><img src="https://gitee.com/josephucas/pcc-beed/raw/master/img/image-20220401225025270.png" alt="image-20220401225025270"></p><p>秩代表着线性变换后空间的维数，更加精确的秩的定义是列空间的维数，秩达到最大值的时候，意味着秩与列数相等，就是满秩</p><p>线性代数视频学习记录</p><ul><li>左乘意味着对右边进行一个变换</li><li>矩阵的相乘中的几何意义需要由右边向左边读，这是起源于我们函数的记号，因为我们将函数写在变量左侧</li><li>矩阵乘积中解的每一列都是和最后边的每一列单独相关的</li><li>点乘后成为一个数，这是左边的向量在右边的向量下的一个投影，这太奇妙了而且可以通过正负号判断他们是否是to。同向的</li><li>行列式表示为对于基准的基，他的变换剪切之后的面积或者体积的变化率是多少，如果是0说明被压缩成了0，他把它压缩到了更小的维度</li><li>行列式的值为负数说明空间的定向发生了改变比如y是在x的左边，那么如果变换后y在x的右边了，那就说明空间的定向发生了改变</li><li>三维空间代表了体积的缩放比例三维空间就是你用右手表示的三维现在只能用左手表示了，所以就也可以说手性其实是因为行列式为负数</li><li>每一个从空间到数轴的变换都能找到一个向量，作为该空间到数轴的对称向量</li></ul>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>P NP NPC NP-hard区别和比较</title>
    <link href="http://example.com/2022/03/24/P-NP-NPC-NP-hard%E5%8C%BA%E5%88%AB%E5%92%8C%E6%AF%94%E8%BE%83/"/>
    <id>http://example.com/2022/03/24/P-NP-NPC-NP-hard%E5%8C%BA%E5%88%AB%E5%92%8C%E6%AF%94%E8%BE%83/</id>
    <published>2022-03-24T08:49:14.000Z</published>
    <updated>2022-03-25T02:31:09.664Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <span id="more"></span><p>这或许是众多OIer最大的误区之一。<br>你会经常看到网上出现“这怎么做，这不是NP问题吗”、“这个只有搜了，这已经被证明是NP问题了”之类的话。你要知道，大多数人此时所说的NP问题其实都是指的NPC问题。他们没有搞清楚NP问题和NPC问题的概念。NP问题并不是那种“只有搜才行”的问题，NPC问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是P问题，什么是NP问题，什么是NPC问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把NP问题当成是 NPC问题是一个多大的错误。</p><p>还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有O(1)的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是O(n)，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于O(n<sup>2)的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是O(a</sup>n)的指数级复杂度，甚至O(n!)的阶乘级复杂度。不会存在O(2<em>n^2)的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。同样地，O (n<sup>3+n</sup>2)的复杂度也就是O(n<sup>3)的复杂度。因此，我们会说，一个O(0.01*n</sup>3)的程序的效率比O(100</em>n<sup>2)的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终O(n</sup>3)的复杂度将远远超过O(n<sup>2)。我们也说，O(n</sup>100)的复杂度小于O(1.01^n)的复杂度。<br>容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是O(1),O(log(n)),O(n<sup>a)等，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；另一种是O(a</sup>n)和O(n!)型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。</p><p>自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。<a href="http://www.matrix67.com/blog/article.asp?id=62">The Halting Problem</a>就是一个著名的不可解问题，在我的Blog上有过专门的介绍和证明。再比如，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。</p><p>下面引入P类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。P是英文单词多项式的第一个字母。哪些问题是P类问题呢？通常NOI和NOIP不会出不属于P类问题的题目。我们常见到的一些信息奥赛的题目都是P问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。<br>接下来引入NP问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我RP很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于100个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度98，比100小。于是答案出来了，存在比100小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比100 小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有Hamilton回路”。<br>之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP问题”，实际上是在探讨NP问题与P类问题的关系。</p><p>很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把所有P类问题归为一个集合P中，把所有 NP问题划进另一个集合NP中，那么，显然有P属于NP。现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有P=NP？通常所谓的“NP问题”，其实就一句话：证明或推翻P=NP。<br>NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问<br>题，好比物理学中的大统一和数学中的歌德巴赫猜想等。<br>目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，也即所谓的 NPC问题。C是英文单词“完全”的第一个字母。正是NPC问题的存在，使人们相信P≠NP。下文将花大量篇幅介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p><p>为了说明NPC问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。<br>简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。<br>“问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。<br>很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。<br>现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。<br>当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p><p>好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于NPC问题”。此时，我的目的终于达到了，我已经把NP问题和NPC问题区别开了。到此为止，本文已经写了近5000字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。</p><p><mark>NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。</mark><br>既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p><p>顺便讲一下<mark>NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</mark></p><p>不要以为NPC问题是一纸空谈。NPC问题是存在的。确实有这么一个非常具体的问题属于NPC问题。下文即将介绍它。<br>下文即将介绍逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。<br>逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。<br>什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。<br>┌───┐<br>│ 输入1├─→┐  ┌──┐<br>└───┘  └─→┤  │<br>│ or ├→─┐<br>┌───┐  ┌─→┤  │  │  ┌──┐<br>│ 输入2├─→┤  └──┘  └─→┤  │<br>&amp;<br>nbsp;└───┘  │        ┌─→┤AND ├──→输出<br>└────────┘┌→┤  │<br>┌───┐  ┌──┐      │ └──┘<br>│ 输入3├─→┤ NOT├─→────┘<br>└───┘  └──┘<br>这是个较简单的逻辑电路，当输入1、输入2、输入3分别为True、True、False或False、True、False时，输出为True。<br>有输出无论如何都不可能为True的逻辑电路吗？有。下面就是一个简单的例子。<br>┌───┐<br>│输入1 ├→─┐  ┌──┐<br>└───┘  └─→┤  │<br>│AND ├─→┐<br>┌─→┤  │  │<br>│  └──┘  │ ┌──┐<br>│        └→┤  │<br>┌───┐  │          │AND ├─→输出<br>│输入2 ├→─┤ ┌──┐   ┌→┤  │<br>└───┘  └→┤NOT ├→──┘ └──┘<br>└──┘<br>上面这个逻辑电路中，无论输入是什么，输出都是False。我们就说，这个逻辑电路不存在使输出为True的一组输入。<br>回到上文，给定一个逻辑电路，问是否存在一种输入使输出为True，这即逻辑电路问题。<br>逻辑电路问题属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。</p><p>有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已知的NPC问题约化到它就行了。后来，Hamilton 回路成了NPC问题，TSP问题也成了NPC问题。现在被证明是NPC问题的有很多，任何一个找到了多项式算法的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。P=NP问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。</p><p>Matrix67原创<br>转载请注明出处</p><blockquote><p><a href="http://www.matrix67.com/blog/archives/105">什么是P问题、NP问题和NPC问题</a></p></blockquote><h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>正态分布学习</title>
    <link href="http://example.com/2022/03/08/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/03/08/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-08T08:43:29.000Z</published>
    <updated>2022-03-25T02:31:09.668Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <p><a href="https://cosx.org/2013/01/story-of-normal-distribution-1/">正态分布的前世今生 (上)</a></p><p><a href="https://cosx.org/2013/01/story-of-normal-distribution-2/">正态分布的前世今生 (下)</a></p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://cosx.org/2013/01/story-of-normal-distribution-1/&quot;&gt;正态分布的前世今生 (上)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cosx.org/2013/01/story-of-normal-distribution-2/&quot;&gt;正态分布的前世今生 (下)&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>rust语言圣经学习</title>
    <link href="http://example.com/2022/02/15/rust%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/02/15/rust%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-02-15T02:10:03.000Z</published>
    <updated>2022-03-25T02:31:09.666Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: VRF算法学习<br>abbrlink: 25666<br>date: 2022-01-07 15:57:26<br>categories:<br>tags:<br>description:<br>top:</p><hr><p align="right">RUST教程笔记</p> <ul><li></li></ul><span id="more"></span><p>避免从入门到放弃</p><ul><li>避免试一试的心态，需要认真对待<ul><li>要提前做好会遇到困难的准备，因为如上面所说，学习 Rust 不仅仅是在学习一门编程语言</li><li>不要抱着试一试的心态去试一试，否则是浪费时间和消耗学习的激情，作为连续六年全世界最受喜欢的语言，Rust 不仅仅是值得试一试 😃</li></ul></li><li>深入学习一本好书或教程<ul><li><a href="https://github.com/sunface/rust-course">rust语言圣经</a></li></ul></li><li><a href="https://course.rs/print.html#%E5%8D%83%E4%B8%87%E5%88%AB%E4%BB%8E%E9%93%BE%E8%A1%A8%E6%88%96%E5%9B%BE%E5%BC%80%E5%A7%8B%E7%BB%83%E6%89%8B">千万别从链表或图开始练手</a></li><li><a href="https://course.rs/print.html#%E4%BB%94%E7%BB%86%E9%98%85%E8%AF%BB%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF">仔细阅读编译错误</a></li><li><a href="https://course.rs/print.html#%E4%B8%8D%E8%A6%81%E5%BC%BA%E5%88%B6%E8%87%AA%E5%B7%B1%E4%BD%BF%E7%94%A8%E5%85%B6%E5%AE%83%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%9D%A5%E5%86%99-rust">不要强制自己使用其它编程语言的最佳实践来写 Rust</a></li></ul><p><a href="https://course.rs/print.html#%E5%9C%A8-linux-%E6%88%96-macos-%E4%B8%8A%E5%AE%89%E8%A3%85-rustup">在 Linux 或 MacOS 上安装 <code>rustup</code></a></p><p>打开终端并输入下面命令：</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl --proto <span class="string">'=https'</span> --tlsv1.2 https://sh.rustup.rs -sSf | sh</span></span><br></pre></td></tr></tbody></table></figure><p>这个命令将下载一个脚本并开始安装 <code>rustup</code> 工具，此工具将安装 Rust 的最新稳定版本。可能会提示你输入管理员密码。</p><p>如果安装成功，将出现下面这行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rust is installed now. Great!</span><br></pre></td></tr></tbody></table></figure><p>OK，这样就已经完成 Rust 安装啦。</p><p><a href="https://course.rs/print.html#%E5%9C%A8-windows-%E4%B8%8A%E5%AE%89%E8%A3%85-rustup">在 Windows 上安装 <code>rustup</code></a></p><h2 id="cargotoml-和-cargolock"><a class="markdownIt-Anchor" href="#cargotoml-和-cargolock"></a> <a href="https://course.rs/print.html#cargotoml-%E5%92%8C-cargolock">Cargo.toml 和 Cargo.lock</a></h2><p><code>Cargo.toml</code> 和 <code>Cargo.lock</code> 是 <code>cargo</code> 的核心文件，它的所有活动均基于此二者。</p><ul><li><code>Cargo.toml</code> 是 <code>cargo</code> 特有的<strong>项目数据描述文件</strong>。它存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 <code>Cargo.toml</code>。</li><li><code>Cargo.lock</code> 文件是 <code>cargo</code> 工具根据同一项目的 <code>toml</code> 文件生成的<strong>项目依赖详细清单</strong>，因此我们一般不用修改它，只需要对着 <code>Cargo.toml</code> 文件撸就行了。</li></ul><blockquote><p>什么情况下该把 <code>Cargo.lock</code> 上传到 git 仓库里？很简单，当你的项目是一个可运行的程序时，就上传 <code>Cargo.lock</code>，如果是一个依赖库项目，那么请把它添加到 <code>.gitignore</code> 中</p></blockquote><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">greet_world</span></span>() {</span><br><span class="line">     <span class="keyword">let</span> southern_germany = <span class="string">"Grüß Gott!"</span>;</span><br><span class="line">     <span class="keyword">let</span> chinese = <span class="string">"世界，你好"</span>;</span><br><span class="line">     <span class="keyword">let</span> english = <span class="string">"World, hello"</span>;</span><br><span class="line">     <span class="keyword">let</span> regions = [southern_germany, chinese, english];</span><br><span class="line">     <span class="keyword">for</span> region <span class="keyword">in</span> regions.iter() {</span><br><span class="line">             <span class="built_in">println!</span>(<span class="string">"{}"</span>, &amp;region);</span><br><span class="line">     }</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">     greet_world();</span><br><span class="line"> }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>其次，关注下 <code>println</code> 后面的 <code>!</code>，如果你有 Ruby 编程经验，那么你可能会认为这是解构操作符，但是在 Rust 中，这是 <code>宏</code> 操作符，你目前可以认为宏是一种特殊类型函数。</p><p>对于 <code>println</code> 来说，我们没有使用其它语言惯用的 <code>%s</code>、<code>%d</code> 来做输出占位符，而是使用 <code>{}</code>，因为 Rust 在底层帮我们做了大量工作，会自动识别输出数据的类型，例如当前例子，会识别为 <code>String</code> 类型。</p><p>最后，和其它语言不同，Rust 的集合类型不能直接进行循环，需要变成迭代器（这里是通过 <code>.iter()</code> 方法），才能用于迭代循环。在目前来看，你会觉得这一点好像挺麻烦，不急，以后就知道这么做的好处所在。</p><blockquote><p>实际上这段代码可以简写，在 2021 edition 及以后，支持直接写 <code>for region in regions</code>，原因会在迭代器章节的开头提到，是因为 for 隐式地将 regions 转换成迭代器。</p></blockquote><p>string和&amp;str的区别</p><p><mark>区分<code>&amp;str</code>和<code>String</code>两个类型是非常有必要的 。<code>&amp;str</code>只读、无所有权，适合切片、字面量等不可变的情形；<code>String</code>可变、持所有权，适合字符串字段类型存储等情形。</mark></p><p>作者：PTLin<br>链接：<a href="https://zhuanlan.zhihu.com/p/384496181">https://zhuanlan.zhihu.com/p/384496181</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="string是什么"><a class="markdownIt-Anchor" href="#string是什么"></a> String是什么？</h2><p>简单来讲，String可以看作由三个变量所组成的结构体，第一个变量为指向一块堆上连续内存的指针，第二个变量为这块内存里已经使用的总大小<em>len</em>，第三个变量为这块的总长度<em>capacity。</em></p><p>String在new的时候从堆里申请内存，在drop的时候释放内存。由于String实现了Drop trait所以String不能为其实现Copy trait。</p><p>String内部的指向的连续内存可以看作为u8的数组，String的使用接口确保了内部存储的确实为合法的UTF-8编码的字节。</p><h2 id="str是什么"><a class="markdownIt-Anchor" href="#str是什么"></a> &amp;str是什么？</h2><p>&amp;str是对String的一种借用形式，被称为字符串切片。</p><p>对String进行deref可以得到&amp;str，而deref内部创建&amp;str的函数<code>from_utf8_unchecked(v: &amp;[u8]) -&gt; &amp;str</code>其内部的原理仅仅是调用了<code>transmute</code>函数对&amp;[u8]的数据进行了重新解释，<code>transmute</code>类似CPP中的<code>reinterpret_cast</code>，所以下文把&amp;str和&amp;[u8]视为一个结构完全相同的类型。</p><p>对于普通的引用其大小为一个usize，内容为被引用变量的地址，但&amp;[T]并不是这样的引用。就如同C语言里字符串在结尾处需要放置一个<code>'\0'</code>当做指示字符串结束的哨兵一样，&amp;[T]也需要某种方式携带被指向的连续内存的长度的元数据，所以&amp;[T]有着两个usize的大小，第一个usize是指向内存的指针，第二个usize为被指向内存总共有多长。</p><p>str是字符串切片，&amp;str是字符串切片引用</p><p>String是字符串，<code>String</code>就是三个玩意组成的：指向缓冲区的堆分配指针，容量，长度。类似于动态数组</p><p>&amp;String是字符串引用</p><p>关系就是对String取地址&amp;得到&amp;String，对String切片得到str，对str取地址得到&amp;str</p><p>在这里你会发现为何在前面强调这一点。字符串切片是一个用途广泛的输入型参数，不仅适用于实际的字符串切片引用，还适用于String引用。所以再强调一遍：如果你需要将一个字符串传递给你的函数，那么请使用字符串切片&amp;str。</p><h2 id="通过例子学-rust-中文版"><a class="markdownIt-Anchor" href="#通过例子学-rust-中文版"></a> <a href="https://rustwiki.org/zh-CN/rust-by-example/index.html">通过例子学 Rust 中文版</a></h2><h2 id="rust-程序设计语言"><a class="markdownIt-Anchor" href="#rust-程序设计语言"></a> <a href="https://kaisery.github.io/trpl-zh-cn/title-page.html#rust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80">Rust 程序设计语言</a></h2><h2 id="rust-编码规范-v-02"><a class="markdownIt-Anchor" href="#rust-编码规范-v-02"></a> <a href="https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/overview.html">Rust 编码规范 V 0.2</a></h2><h2 id="rust语言圣经rust教程-rust-course"><a class="markdownIt-Anchor" href="#rust语言圣经rust教程-rust-course"></a> <a href="https://course.rs/">Rust语言圣经(Rust教程 Rust Course)</a></h2><h2 id="通过大量的链表学习rust"><a class="markdownIt-Anchor" href="#通过大量的链表学习rust"></a> <a href="https://weathfold.gitbooks.io/rust-too-many-lists-zhcn/content/">通过大量的链表学习Rust</a></h2><h2 id="rust-primer"><a class="markdownIt-Anchor" href="#rust-primer"></a> <a href="https://hardocs.com/d/rustprimer/index.html">rust Primer</a></h2>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;title: VRF算法学习&lt;br&gt;
abbrlink: 25666&lt;br&gt;
date: 2022-01-07 15:57:26&lt;br&gt;
categories:&lt;br&gt;
tags:&lt;br&gt;
description:&lt;br&gt;
top:&lt;/p&gt;
&lt;hr&gt;
&lt;p align=&quot;right&quot;&gt;RUST教程笔记&lt;/p&gt; 
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链分片整理</title>
    <link href="http://example.com/2022/01/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%88%86%E7%89%87%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2022/01/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%88%86%E7%89%87%E6%95%B4%E7%90%86/</id>
    <published>2022-01-18T11:54:38.000Z</published>
    <updated>2022-02-14T13:20:12.737Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <span id="more"></span><p><a href="https://zhuanlan.zhihu.com/p/47537732">区块链分片的常见问题和回答（上）</a></p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>拜占庭共识算法PBFT学习</title>
    <link href="http://example.com/2022/01/13/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95PBFT%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/01/13/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95PBFT%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-01-13T11:46:25.000Z</published>
    <updated>2022-09-27T08:24:42.630Z</updated>
    
    <content type="html"><![CDATA[<p align="right">PBFT共识机制学习</p> <span id="more"></span><p>bft算法有一个死结，现实工业社会不准许机构节点之间全部互相开防火墙通信。</p>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;PBFT共识机制学习&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Proof of Reputation: A Reputation-Based Consensus Protocol for Peer-to-Peer Network</title>
    <link href="http://example.com/2022/01/13/Proof-of-Reputation-A-Reputation-Based-Consensus-Protocol-for-Peer-to-Peer-Network/"/>
    <id>http://example.com/2022/01/13/Proof-of-Reputation-A-Reputation-Based-Consensus-Protocol-for-Peer-to-Peer-Network/</id>
    <published>2022-01-13T03:02:55.000Z</published>
    <updated>2022-01-17T16:09:07.000Z</updated>
    
    <content type="html"><![CDATA[<p align="right">副标题</p> <h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>除了加密货币，区块链还可以保护声誉，现有的利用区块链提升声誉系统的研究都建立在比特币的区块链之上，因此他们本质上受到底层区块链的低效率和高消耗的限制（我想做的是用底层网络的声誉机制模型，去解决区块链的低效率和高消耗的问题）为了填补这个差距，我们提出一种基于信誉的共识协议（POR）它保证了交易的可靠性和完整性，且让声誉作为良好行为和区块发布的激励，而不是数字货币，所以不需要矿工。我们还实现了一个原型，我们的可伸缩性实验表明，我们的协议可以在一个超过每秒数百个交易的点对点网络中拓展到1000多个参与者</p><h2 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h2><p>区块链，共识协议，声誉系统，点对点网络</p><span id="more"></span><h2 id="研究问题"><a class="markdownIt-Anchor" href="#研究问题"></a> 研究问题</h2><h3 id="研究背景简要介绍"><a class="markdownIt-Anchor" href="#研究背景简要介绍"></a> 研究背景(简要介绍)</h3><p>事实上矿工和数字货币不是必须的，只要提供适当的激励来去维持区块链潜在的安全性</p><h3 id="研究问题或解决技术问题描述需定位和描述清晰"><a class="markdownIt-Anchor" href="#研究问题或解决技术问题描述需定位和描述清晰"></a> 研究问题或解决技术问题描述（需定位和描述清晰）</h3><h2 id="研究现状"><a class="markdownIt-Anchor" href="#研究现状"></a> 研究现状</h2><h3 id="围绕研究问题进行相关研究成果列举注明参考文献"><a class="markdownIt-Anchor" href="#围绕研究问题进行相关研究成果列举注明参考文献"></a> 围绕研究问题，进行相关研究成果列举（注明参考文献）</h3><h3 id="研究现状总结及现有研究仍然存在不足或问题"><a class="markdownIt-Anchor" href="#研究现状总结及现有研究仍然存在不足或问题"></a> 研究现状总结，及现有研究仍然存在不足或问题</h3><h2 id="思路特色"><a class="markdownIt-Anchor" href="#思路特色"></a> 思路特色</h2><h3 id="与现有研究技术手段不同之处"><a class="markdownIt-Anchor" href="#与现有研究技术手段不同之处"></a> 与现有研究（技术手段）不同之处</h3><h2 id="关键问题技术点"><a class="markdownIt-Anchor" href="#关键问题技术点"></a> 关键问题/技术点</h2><h3 id="围绕研究题目提炼出需要解决的几个关键问题点技术点"><a class="markdownIt-Anchor" href="#围绕研究题目提炼出需要解决的几个关键问题点技术点"></a> 围绕研究题目，提炼出需要解决的几个关键问题点/技术点</h3><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><h3 id="总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"><a class="markdownIt-Anchor" href="#总体解决方案最好能画一个总体方案图-或有一段描述清楚总体思路"></a> 总体解决方案（最好能画一个总体方案图、或有一段描述清楚总体思路）</h3><h3 id="每个问题点技术点分别的解决方案或模型设计"><a class="markdownIt-Anchor" href="#每个问题点技术点分别的解决方案或模型设计"></a> 每个问题点/技术点分别的解决方案或模型设计</h3><h2 id="实验设计结果分析"><a class="markdownIt-Anchor" href="#实验设计结果分析"></a> 实验设计&amp;结果分析</h2><h3 id="场景选择-实验设计-指标选取"><a class="markdownIt-Anchor" href="#场景选择-实验设计-指标选取"></a> 场景选择、实验设计、指标选取</h3><h3 id="实验结果分析"><a class="markdownIt-Anchor" href="#实验结果分析"></a> 实验结果分析</h3><h2 id="论文结论"><a class="markdownIt-Anchor" href="#论文结论"></a> 论文结论</h2><h3 id="得出文章结论"><a class="markdownIt-Anchor" href="#得出文章结论"></a> 得出文章结论</h3>]]></content>
    
    
    <summary type="html">&lt;p align=&quot;right&quot;&gt;副标题&lt;/p&gt; 
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#摘要&quot;&gt;&lt;/a&gt; 摘要&lt;/h2&gt;
&lt;p&gt;除了加密货币，区块链还可以保护声誉，现有的利用区块链提升声誉系统的研究都建立在比特币的区块链之上，因此他们本质上受到底层区块链的低效率和高消耗的限制（我想做的是用底层网络的声誉机制模型，去解决区块链的低效率和高消耗的问题）为了填补这个差距，我们提出一种基于信誉的共识协议（POR）它保证了交易的可靠性和完整性，且让声誉作为良好行为和区块发布的激励，而不是数字货币，所以不需要矿工。我们还实现了一个原型，我们的可伸缩性实验表明，我们的协议可以在一个超过每秒数百个交易的点对点网络中拓展到1000多个参与者&lt;/p&gt;
&lt;h2 id=&quot;关键词&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关键词&quot;&gt;&lt;/a&gt; 关键词&lt;/h2&gt;
&lt;p&gt;区块链，共识协议，声誉系统，点对点网络&lt;/p&gt;</summary>
    
    
    
    <category term="区块链" scheme="http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="共识机制" scheme="http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
    
    <category term="声誉共识" scheme="http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/%E5%A3%B0%E8%AA%89%E5%85%B1%E8%AF%86/"/>
    
    
    <category term="声誉机制" scheme="http://example.com/tags/%E5%A3%B0%E8%AA%89%E6%9C%BA%E5%88%B6/"/>
    
    <category term="共识机制" scheme="http://example.com/tags/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
</feed>
